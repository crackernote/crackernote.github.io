<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>x86 Assembly 기초 | CrackerNote</title>
<meta name=keywords content><meta name=description content="1️⃣ X86 Assembly 기초 📜x86 아키텍처 - 데이터 타입 : 어셈블리 기본
- 주소 표기법 : 리틀 엔디안
- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS
- 호출규약 : cdecl, stdcall, fastcall
- 명령어 세트 : 가변 길이 명령어 형식을 사용
- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자
- 기본문법 : AT&amp;T(add a,b > b=a+b) 또는 Intel (add a,b > a=a+b)
📜레지스터 - 8개의 범용 레지스터 + EIP(32비트)
- EFLAGS 레지스터(32비트)"><meta name=author content="Me"><link rel=canonical href=https://crackernote.github.io/posts/2022-07-16-x86-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EA%B8%B0%EC%B4%88/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://crackernote.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://crackernote.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://crackernote.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://crackernote.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://crackernote.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://crackernote.github.io/posts/2022-07-16-x86-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EA%B8%B0%EC%B4%88/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="x86 Assembly 기초"><meta property="og:description" content="1️⃣ X86 Assembly 기초 📜x86 아키텍처 - 데이터 타입 : 어셈블리 기본
- 주소 표기법 : 리틀 엔디안
- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS
- 호출규약 : cdecl, stdcall, fastcall
- 명령어 세트 : 가변 길이 명령어 형식을 사용
- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자
- 기본문법 : AT&amp;T(add a,b > b=a+b) 또는 Intel (add a,b > a=a+b)
📜레지스터 - 8개의 범용 레지스터 + EIP(32비트)
- EFLAGS 레지스터(32비트)"><meta property="og:type" content="article"><meta property="og:url" content="https://crackernote.github.io/posts/2022-07-16-x86-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EA%B8%B0%EC%B4%88/"><meta property="og:image" content="https://crackernote.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="CrackerNote"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://crackernote.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="x86 Assembly 기초"><meta name=twitter:description content="1️⃣ X86 Assembly 기초 📜x86 아키텍처 - 데이터 타입 : 어셈블리 기본
- 주소 표기법 : 리틀 엔디안
- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS
- 호출규약 : cdecl, stdcall, fastcall
- 명령어 세트 : 가변 길이 명령어 형식을 사용
- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자
- 기본문법 : AT&amp;T(add a,b > b=a+b) 또는 Intel (add a,b > a=a+b)
📜레지스터 - 8개의 범용 레지스터 + EIP(32비트)
- EFLAGS 레지스터(32비트)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://crackernote.github.io/posts/"},{"@type":"ListItem","position":2,"name":"x86 Assembly 기초","item":"https://crackernote.github.io/posts/2022-07-16-x86-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EA%B8%B0%EC%B4%88/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"x86 Assembly 기초","name":"x86 Assembly 기초","description":"1️⃣ X86 Assembly 기초 📜x86 아키텍처 - 데이터 타입 : 어셈블리 기본\n- 주소 표기법 : 리틀 엔디안\n- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS\n- 호출규약 : cdecl, stdcall, fastcall\n- 명령어 세트 : 가변 길이 명령어 형식을 사용\n- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자\n- 기본문법 : AT\u0026amp;T(add a,b \u0026gt; b=a+b) 또는 Intel (add a,b \u0026gt; a=a+b)\n📜레지스터 - 8개의 범용 레지스터 + EIP(32비트)\n- EFLAGS 레지스터(32비트)","keywords":[],"articleBody":"1️⃣ X86 Assembly 기초 📜x86 아키텍처 - 데이터 타입 : 어셈블리 기본\n- 주소 표기법 : 리틀 엔디안\n- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS\n- 호출규약 : cdecl, stdcall, fastcall\n- 명령어 세트 : 가변 길이 명령어 형식을 사용\n- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자\n- 기본문법 : AT\u0026T(add a,b \u003e b=a+b) 또는 Intel (add a,b \u003e a=a+b)\n📜레지스터 - 8개의 범용 레지스터 + EIP(32비트)\n- EFLAGS 레지스터(32비트)\n- 세그먼트 레지스터(16비트)\n- EAX(Extended Accumulator Register) : 산술 연산에 사용, 함수 리턴값 저장\n- EBX(Extended Base Register) : 베이스, 특정 메모리를 가리키는 포인터\n- ECX(Extended Count Register) : 카운터 코드에 사용 (흔히 for문 등의 카운터에 사용)\n- EDX(Extended Data Register) : 데이터 레지스터 (곱셈, 나눗셈)\n- ESI(Extended Source Index) : 문자열 연산의 출발지 포인터\n- EDI(Extended Destionation Index) : 문자열 연산의 목적지 포인터 - ESP(Extended Stack Point) : 스택 포인터 - EBP(Extended Base Point) : 스택 프레임 베이스 포인터 .스택의 기준\n- EIP(Extended Instruction Point) : 다음 실행할 명령어를 가리키는 포인터\n📜EFLAGS 레지스터 - 상태 플래그\n- 방향 플래그\n- 시스템 \u0026 IOPL 플래그\n- CF : Carry\n- PF : Parity\n- AF : Adjust\n- ZF : Zero\n- SF : Sign\n- OF : Overflow\n📜자주쓰는 명령어 명령어 유형 의미 대표 명령어 세트 데이터 이동 src에서 dst로 이동 mov, lea, push, pop, les, pushad, popad 산술 정수의 산술 연산 add, adc, sub, sbb, mul, imul, div, idev, cmp, inc, dec 부동 소수점 부동 소수점 산술 연산 fadd, fsub, fmul, dic, cmp 논리 비트 논리 연산 adn, or, xor, not, shl/sal, shr, sar, ror, rol 제어 이동 제어 흐름의 이동 jmp, jcc, call, ret, int, into 문자열 문자열의 비교, 이동 movs, stos, sca, outs, rep, repz, repnz, repne I/O 입력과 출력 in, out 변환 데이터 타입 변환 movzx, movsx, cbw, cdq, bswap 기타 플래그 조작, 특권 모드 처리 clc, stc, cmc, std, cl, sti 📜PUSH, POP - PUSH : 스택에 데이터를 삽입 \u003e push word/dword\n\u003e push 명령어는 자동으로 ESP를 4바이트 감소시킴\n- POP : 스택에서 데이터를 꺼냄\n\u003e 스택에서 4바이트를 꺼내와 지정한 레지스터에 삽입\n\u003e POP 명령어는 자동으로 ESP를 4바이트 증가 시킴\n📜MOV - 레지스터 \u003c-\u003e 레지스터 (가능)\n- 메모리 \u003c-\u003e 레지스터 (가능)\n- Immediate 값(메모리가 아닌 명령어에 포함된 값) -\u003e 레지스터 또는 메모리 (가능)\n- 메모리 \u003c-\u003e 메모리 (불가능)\n📜Assembly 프로그래밍 정상적으로 끝내는 방법 - mov eax, 1\nmov ebx, 0\nint 80h\n\u003eexit(0) 의 역할을 함\n📜‘r/m32’ 주소형식 - 다음과 같은 형식을 가지는 문법을 의미 • mov eax, ebx ← ebx 에 담긴 내용을 eax 로 복사 • mov eax, [ebx] ← ebx에 담긴 내용이 가리키는 주소의 내용 (포인터 )을 eax 로 복사 • mov eax, [ebx+ecxX] ← ebx에서 ecxX 만큼 떨어진 곳에 위치한 주소의 내용을 eax 로 복사 • mov eax, [ebx + ecxX + Y] ← ebx에서 ecxX + Y 만큼 떨어진 곳에 위치한 주소의 내용을 eax 로 복사\n📜ADD, SUB - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- 출발지와 목적지가 모두 r/m32일 수는 없음\n- OF, SF, ZF, AF, PF, CF에 영향\n📜LEA (복사, Load Effective Address - 유효주소 로드) - 출발지는 r/m32\n- 목적지는 레지스터\n- 레지스터 연살 결과를 레지스터에 저장 (포인터 아님)\n- MOV와 다른점\n\u003e MOV는 값을 로드함, mov eax, [ebp+esp+4] \u003e [ebp+esp+4]의 주소가 가리키는 값을 로드함\n\u003e LEA는 유효 주소를 로드, lea eax, [ebp+esp+4] \u003e [ebp+esp+4]의 주소를 로드함\n📜AND - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- OF, CF, SF, ZF, PF\n📜OR - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- OF, CF, SF, ZF, PF\n📜XOR - 목적지는 r/m32 또는 레지스터\n- 출발지는 r/m32 또는 레지스터 또는 상수값\n- OF, CF, SF, ZF, PF\n📜INC - 피연산자의 값을 1 증가시킴 \u003e OF, SF, ZF, AF, PF에 영향\n📜DEC - 피연산자의 값을 1 감소시킴 \u003e OF, SF, ZF, AF, PF에 영향\n📜CMP(두 값을 비교) - cmp 레지스터, 상수값\n- cmp r/m32, 상수값\n- cmp r/m32, 레지스터\n- cmp 레지스터, r/m32\n- 출발지에서 목적지 값을 뺀 결과를 플래그에 반영\n- 결과는버림\n📜TEST(논리비교) - test eax, eax(eax 값이 0인 경우 ZF=1)\n- 보통 jcc랑 같이 쓰임\n📜제어흐름 - 조건부 제어 : IF, WHILE, SWITCH\n- 비조건부 제어 : CALL, GOTO, EXCEPTION, INTERRUPT\n📜JMP(jump) - 피연산자 주소로 EIP를 변경\n- Short Jump(OF 85) : 현재 EIP 값에서 -128~127 범위로 이동\n- Far Jump(75) : 다른 세그먼트에 위치한 명령어로 이동\n📜JCC (Jump if condition is met) - 특정 조건을 만족할 경우 지정한 주소로 제어 흐름을 이동\n- JNE : Jump Not Equal (ZF=0)\n- JE : Jump Equal (ZF=1)\n- JLE : Jump Less Equal (ZF=1 or SF\u003c\u003eOF)\n📜CALL(함수 호출) - call printf / 0x80480000 / [eax + 4]\n- 우선 다음 실행할 명령어 주소를 스택에 삽입한 뒤 EIP에 해당 주소를 옮긴 뒤 이동하는 방식\n- 외부 함수를 사용하는 경우 반드시 해당 함수가 포함된 라이브러리를 linker에 함께 전달해야 함\n📜x86 함수 호출 규약 - cdecl\n\u003e x86 환경에서 대부분 C 컴파일러가 쓰는 규약\n\u003e Caller에서 스택을 정리\n\u003e 오른쪽에서 왼쪽 순서로 파라미터를 전달\n\u003e 항상 스택의 최상위에 함수의 첫 번째 파라미터가 위치\n- stdcall\n\u003e MS가 자체적으로 만든 호출규약 (Win32 API에서 사용)\n\u003e 파라미터 입력 순서는 cdecl과 동일\n\u003e Callee가 스택을 정리\n\u003e 작고 빠른 프로그램에 용이\n- 함수가 시작될 때, Callee가 Stack에 2가지 값을 저장\n\u003e EIP : caller의 next instruction (다시 돌아갔을때 실행할 명령어 위치)\n\u003e EBP : caller의 base pointer, main함수 시작부분 (다시 돌아갔을때 스택 프레임 기준)\n","wordCount":"886","inLanguage":"en","image":"https://crackernote.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://crackernote.github.io/posts/2022-07-16-x86-%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC-%EA%B8%B0%EC%B4%88/"},"publisher":{"@type":"Organization","name":"CrackerNote","logo":{"@type":"ImageObject","url":"https://crackernote.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://crackernote.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://crackernote.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://crackernote.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://crackernote.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://crackernote.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://crackernote.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://crackernote.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">x86 Assembly 기초</h1><div class=post-meta>5 min&nbsp;·&nbsp;886 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/2022-07-16-x86%20%ec%96%b4%ec%85%88%eb%b8%94%eb%a6%ac%20%ea%b8%b0%ec%b4%88.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=1-x86-assembly-기초>1️⃣ X86 Assembly 기초<a hidden class=anchor aria-hidden=true href=#1-x86-assembly-기초>#</a></h2><h4 id=x86-아키텍처>📜<strong>x86 아키텍처</strong><a hidden class=anchor aria-hidden=true href=#x86-아키텍처>#</a></h4><p>- 데이터 타입 : 어셈블리 기본</p><p>- 주소 표기법 : 리틀 엔디안</p><p>- 레지스터 : 8개의 범용 레지스터, EIP, EFLAGS</p><p>- 호출규약 : cdecl, stdcall, fastcall</p><p>- 명령어 세트 : 가변 길이 명령어 형식을 사용</p><p>- 피연산자 : 레지스터, 메모리 주소, 주소값, 숫자</p><p>- 기본문법 : AT&amp;T(add a,b > b=a+b) 또는 Intel (add a,b > a=a+b)</p><h4 id=레지스터>📜<strong>레지스터</strong><a hidden class=anchor aria-hidden=true href=#레지스터>#</a></h4><p>- 8개의 범용 레지스터 + EIP(32비트)</p><p>- EFLAGS 레지스터(32비트)</p><p>- 세그먼트 레지스터(16비트)</p><p><img loading=lazy src=https://blog.kakaocdn.net/dn/dL8uDV/btqCOflvPYL/gJIZkchktxT7hKpdiYFDg1/img.png alt=img></p><p>- EAX(Extended Accumulator Register) : 산술 연산에 사용, 함수 리턴값 저장</p><p>- EBX(Extended Base Register) : 베이스, 특정 메모리를 가리키는 포인터</p><p>- ECX(Extended Count Register) : 카운터 코드에 사용 (흔히 for문 등의 카운터에 사용)</p><p>- EDX(Extended Data Register) : 데이터 레지스터 (곱셈, 나눗셈)</p><p>- ESI(Extended Source Index) : 문자열 연산의 출발지 포인터</p><p>- EDI(Extended Destionation Index) : 문자열 연산의 목적지 포인터
- ESP(Extended Stack Point) : 스택 포인터
- EBP(Extended Base Point) : 스택 프레임 베이스 포인터 .스택의 기준</p><p>- EIP(Extended Instruction Point) : 다음 실행할 명령어를 가리키는 포인터</p><h4 id=eflags-레지스터>📜<strong>EFLAGS 레지스터</strong><a hidden class=anchor aria-hidden=true href=#eflags-레지스터>#</a></h4><p>- 상태 플래그</p><p>- 방향 플래그</p><p>- 시스템 & IOPL 플래그</p><p><img loading=lazy src=https://blog.kakaocdn.net/dn/cSrtyC/btqCOfsh4zI/BAHBdhrXZqlxeO1Mku5Ta1/img.png alt=img></p><p>- CF : Carry</p><p>- PF : Parity</p><p>- AF : Adjust</p><p>- ZF : Zero</p><p>- SF : Sign</p><p>- OF : Overflow</p><h4 id=자주쓰는-명령어>📜<strong>자주쓰는 명령어</strong><a hidden class=anchor aria-hidden=true href=#자주쓰는-명령어>#</a></h4><table><thead><tr><th><strong>명령어 유형</strong></th><th><strong>의미</strong></th><th><strong>대표 명령어 세트</strong></th></tr></thead><tbody><tr><td>데이터 이동</td><td>src에서 dst로 이동</td><td>mov, lea, push, pop, les, pushad, popad</td></tr><tr><td>산술</td><td>정수의 산술 연산</td><td>add, adc, sub, sbb, mul, imul, div, idev, cmp, inc, dec</td></tr><tr><td>부동 소수점</td><td>부동 소수점 산술 연산</td><td>fadd, fsub, fmul, dic, cmp</td></tr><tr><td>논리</td><td>비트 논리 연산</td><td>adn, or, xor, not, shl/sal, shr, sar, ror, rol</td></tr><tr><td>제어 이동</td><td>제어 흐름의 이동</td><td>jmp, jcc, call, ret, int, into</td></tr><tr><td>문자열</td><td>문자열의 비교, 이동</td><td>movs, stos, sca, outs, rep, repz, repnz, repne</td></tr><tr><td>I/O</td><td>입력과 출력</td><td>in, out</td></tr><tr><td>변환</td><td>데이터 타입 변환</td><td>movzx, movsx, cbw, cdq, bswap</td></tr><tr><td>기타</td><td>플래그 조작, 특권 모드 처리</td><td>clc, stc, cmc, std, cl, sti</td></tr></tbody></table><h4 id=push-pop>📜<strong>PUSH, POP</strong><a hidden class=anchor aria-hidden=true href=#push-pop>#</a></h4><p>- PUSH : 스택에 데이터를 삽입
> push word/dword</p><p>> push 명령어는 자동으로 ESP를 4바이트 감소시킴</p><p>- POP : 스택에서 데이터를 꺼냄</p><p>> 스택에서 4바이트를 꺼내와 지정한 레지스터에 삽입</p><p>> POP 명령어는 자동으로 ESP를 4바이트 증가 시킴</p><h4 id=mov>📜<strong>MOV</strong><a hidden class=anchor aria-hidden=true href=#mov>#</a></h4><p>- 레지스터 &lt;-> 레지스터 (가능)</p><p>- 메모리 &lt;-> 레지스터 (가능)</p><p>- Immediate 값(메모리가 아닌 명령어에 포함된 값) -> 레지스터 또는 메모리 (가능)</p><p>- 메모리 &lt;-> 메모리 (불가능)</p><h4 id=assembly-프로그래밍-정상적으로-끝내는-방법>📜<strong>Assembly 프로그래밍 정상적으로 끝내는 방법</strong><a hidden class=anchor aria-hidden=true href=#assembly-프로그래밍-정상적으로-끝내는-방법>#</a></h4><p>- mov eax, 1</p><p>mov ebx, 0</p><p>int 80h</p><p>>exit(0) 의 역할을 함</p><h4 id=rm32-주소형식>📜<strong>&lsquo;r/m32&rsquo; 주소형식</strong><a hidden class=anchor aria-hidden=true href=#rm32-주소형식>#</a></h4><p>- 다음과 같은 형식을 가지는 문법을 의미
• mov eax, ebx ← ebx 에 담긴 내용을 eax 로 복사
• mov eax, [ebx] ← ebx에 담긴 내용이 가리키는 주소의 내용 (포인터 )을 eax 로 복사
• mov eax, [ebx+ecx<em>X] ← ebx에서 ecx</em>X 만큼 떨어진 곳에 위치한 주소의 내용을 eax 로 복사
• mov eax, [ebx + ecx<em>X + Y] ← ebx에서 ecx</em>X + Y 만큼 떨어진 곳에 위치한 주소의 내용을 eax 로 복사</p><h4 id=add-sub>📜<strong>ADD, SUB</strong><a hidden class=anchor aria-hidden=true href=#add-sub>#</a></h4><p>- 목적지는 r/m32 또는 레지스터</p><p>- 출발지는 r/m32 또는 레지스터 또는 상수값</p><p>- 출발지와 목적지가 모두 r/m32일 수는 없음</p><p>- OF, SF, ZF, AF, PF, CF에 영향</p><h4 id=lea-복사-load-effective-address---유효주소-로드>📜<strong>LEA (복사, Load Effective Address - 유효주소 로드)</strong><a hidden class=anchor aria-hidden=true href=#lea-복사-load-effective-address---유효주소-로드>#</a></h4><p>- 출발지는 r/m32</p><p>- 목적지는 레지스터</p><p>- 레지스터 연살 결과를 레지스터에 저장 (포인터 아님)</p><p>- MOV와 다른점</p><p>> MOV는 값을 로드함, <strong>mov eax, [ebp+esp+4] > [ebp+esp+4]의 주소가 가리키는 값을 로드함</strong></p><p>> LEA는 유효 주소를 로드, <strong>lea eax, [ebp+esp+4] > [ebp+esp+4]의 주소를 로드함</strong></p><h4 id=and>📜<strong>AND</strong><a hidden class=anchor aria-hidden=true href=#and>#</a></h4><p>- 목적지는 r/m32 또는 레지스터</p><p>- 출발지는 r/m32 또는 레지스터 또는 상수값</p><p>- OF, CF, SF, ZF, PF</p><h4 id=or>📜<strong>OR</strong><a hidden class=anchor aria-hidden=true href=#or>#</a></h4><p>- 목적지는 r/m32 또는 레지스터</p><p>- 출발지는 r/m32 또는 레지스터 또는 상수값</p><p>- OF, CF, SF, ZF, PF</p><h4 id=xor>📜<strong>XOR</strong><a hidden class=anchor aria-hidden=true href=#xor>#</a></h4><p>- 목적지는 r/m32 또는 레지스터</p><p>- 출발지는 r/m32 또는 레지스터 또는 상수값</p><p>- OF, CF, SF, ZF, PF</p><h4 id=inc>📜<strong>INC</strong><a hidden class=anchor aria-hidden=true href=#inc>#</a></h4><p>- 피연산자의 값을 1 증가시킴
> OF, SF, ZF, AF, PF에 영향</p><h4 id=dec>📜<strong>DEC</strong><a hidden class=anchor aria-hidden=true href=#dec>#</a></h4><p>- 피연산자의 값을 1 감소시킴
> OF, SF, ZF, AF, PF에 영향</p><h4 id=cmp두-값을-비교>📜<strong>CMP(두 값을 비교)</strong><a hidden class=anchor aria-hidden=true href=#cmp두-값을-비교>#</a></h4><p>- cmp 레지스터, 상수값</p><p>- cmp r/m32, 상수값</p><p>- cmp r/m32, 레지스터</p><p>- cmp 레지스터, r/m32</p><p>- 출발지에서 목적지 값을 뺀 결과를 플래그에 반영</p><p>- 결과는버림</p><h4 id=test논리비교>📜<strong>TEST(논리비교)</strong><a hidden class=anchor aria-hidden=true href=#test논리비교>#</a></h4><p>- test eax, eax(eax 값이 0인 경우 ZF=1)</p><p>- 보통 jcc랑 같이 쓰임</p><h4 id=제어흐름>📜<strong>제어흐름</strong><a hidden class=anchor aria-hidden=true href=#제어흐름>#</a></h4><p>- 조건부 제어 : IF, WHILE, SWITCH</p><p>- 비조건부 제어 : CALL, GOTO, EXCEPTION, INTERRUPT</p><h4 id=jmpjump>📜<strong>JMP(jump)</strong><a hidden class=anchor aria-hidden=true href=#jmpjump>#</a></h4><p>- 피연산자 주소로 EIP를 변경</p><p>- Short Jump(OF 85) : 현재 EIP 값에서 -128~127 범위로 이동</p><p>- Far Jump(75) : 다른 세그먼트에 위치한 명령어로 이동</p><h4 id=jcc-jump-if-condition-is-met>📜<strong>JCC (Jump if condition is met)</strong><a hidden class=anchor aria-hidden=true href=#jcc-jump-if-condition-is-met>#</a></h4><p>- 특정 조건을 만족할 경우 지정한 주소로 제어 흐름을 이동</p><p>- JNE : Jump Not Equal (ZF=0)</p><p>- JE : Jump Equal (ZF=1)</p><p>- JLE : Jump Less Equal (ZF=1 or SF&lt;>OF)</p><h4 id=call함수-호출>📜<strong>CALL(함수 호출)</strong><a hidden class=anchor aria-hidden=true href=#call함수-호출>#</a></h4><p>- call printf / 0x80480000 / [eax + 4]</p><p>- 우선 다음 실행할 명령어 주소를 스택에 삽입한 뒤 EIP에 해당 주소를 옮긴 뒤 이동하는 방식</p><p>- 외부 함수를 사용하는 경우 반드시 해당 함수가 포함된 라이브러리를 linker에 함께 전달해야 함</p><h4 id=x86-함수-호출-규약>📜<strong>x86 함수 호출 규약</strong><a hidden class=anchor aria-hidden=true href=#x86-함수-호출-규약>#</a></h4><p>- cdecl</p><p>> x86 환경에서 대부분 C 컴파일러가 쓰는 규약</p><p>> Caller에서 스택을 정리</p><p>> 오른쪽에서 왼쪽 순서로 파라미터를 전달</p><p>> 항상 스택의 최상위에 함수의 첫 번째 파라미터가 위치</p><p>- stdcall</p><p>> MS가 자체적으로 만든 호출규약 (Win32 API에서 사용)</p><p>> 파라미터 입력 순서는 cdecl과 동일</p><p>> Callee가 스택을 정리</p><p>> 작고 빠른 프로그램에 용이</p><p>- 함수가 시작될 때, Callee가 Stack에 2가지 값을 저장</p><p>> EIP : caller의 next instruction
(다시 돌아갔을때 실행할 명령어 위치)</p><p>> EBP : caller의 base pointer, main함수 시작부분
(다시 돌아갔을때 스택 프레임 기준)</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://crackernote.github.io/posts/2023-06-07-tryhackme_basic-pentesting/><span class=title>« Prev</span><br><span>TryHackMe Basic Pentesting</span>
</a><a class=next href=https://crackernote.github.io/posts/2023-03-26-%EB%84%A4%EC%9D%B4%EB%B2%84-%EB%89%B4%EC%8A%A4-%ED%81%AC%EB%A1%A4%EB%9F%AC/><span class=title>Next »</span><br><span>네이버 뉴스 크롤러</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share x86 Assembly 기초 on x" href="https://x.com/intent/tweet/?text=x86%20Assembly%20%ea%b8%b0%ec%b4%88&amp;url=https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share x86 Assembly 기초 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f&amp;title=x86%20Assembly%20%ea%b8%b0%ec%b4%88&amp;summary=x86%20Assembly%20%ea%b8%b0%ec%b4%88&amp;source=https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share x86 Assembly 기초 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f&title=x86%20Assembly%20%ea%b8%b0%ec%b4%88"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share x86 Assembly 기초 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share x86 Assembly 기초 on whatsapp" href="https://api.whatsapp.com/send?text=x86%20Assembly%20%ea%b8%b0%ec%b4%88%20-%20https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share x86 Assembly 기초 on telegram" href="https://telegram.me/share/url?text=x86%20Assembly%20%ea%b8%b0%ec%b4%88&amp;url=https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share x86 Assembly 기초 on ycombinator" href="https://news.ycombinator.com/submitlink?t=x86%20Assembly%20%ea%b8%b0%ec%b4%88&u=https%3a%2f%2fcrackernote.github.io%2fposts%2f2022-07-16-x86-%25EC%2596%25B4%25EC%2585%2588%25EB%25B8%2594%25EB%25A6%25AC-%25EA%25B8%25B0%25EC%25B4%2588%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://crackernote.github.io/>CrackerNote</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>